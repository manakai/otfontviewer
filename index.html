<!DOCTYPE html>
<html lang=en>
  <meta charset=utf-8>
  <title>OpenType font viewer</title>
  <script src=opentype.js></script>
  <script src=components.js async data-export="$fill" data-time-selector="time"></script>
  <link rel=stylesheet href=viewer.css>

  <font-viewer>
    <tab-set>
      <tab-menu>
        <tab-menu-extras>
          <progress hidden></progress>
        </tab-menu-extras>
      </tab-menu>
      <section>
        <h1>OpenType font viewer</h1>

        <form is=upload-form>
          <p>
            <label>
              Open a font file:
              <input type=file name=file multiple accept=".ttf, .ttc, .otf, .tte, .eot, .woff, .woff2">
            </label>
        </form>
        <form is=upload-form>
          <p>
            <label>
              Open a font by URL:
              <input type=url name=url>
              <button type=submit>Open</button>
            </label>
        </form>

        <ul class=logs></ul>

        <footer>
          <p><a href=https://github.com/manakai/otfontviewer>Repository</a>
          <p><sw-ads-notes></sw-ads-notes>
        </footer>
      </section>
    </tab-set>
  </font-viewer>
  <script src="https://manakai.github.io/js/global.js" async></script>

  <script>

var defineElement = function (def) {
  var e = document.createElementNS ('data:,pc', 'element');
  e.pcDef = def;
  document.head.appendChild (e);

  if (def.fill) {
    var e = document.createElementNS ('data:,pc', 'filltype');
    e.setAttribute ('name', def.name);
    e.setAttribute ('content', def.fill);
    document.head.appendChild (e);
    delete def.fill;
  }
}; // defineElement

    var OT = {

      _extractCombinations: function (xx, cCount, start, end) {
        if (start > end) return [];
        
        var vv = [];
        xx.reverse ().forEach (([c, p]) => {
          var n = cCount (c);
          vv.unshift ([c, n, start % n, end % n, p]);
          start = Math.floor (start / n);
          end = Math.floor (end / n);
        });

        var values = [];
        if (vv.length) {
          while (true) {
            var w = [];
            var isLast = true;
            for (var j = 0; j < vv.length; j++) {
              var _ = vv[j];
              w.push ([_[0], _[2], _[4]]);
              if (_[2] !== _[3]) isLast = false;
            }
            values.push (w);
            if (isLast) break;

                for (var j = vv.length-1; j >= 0; j--) {
                  var _ = vv[j];
                  _[2]++;
                  if (_[2] === _[1]) {
                    for (var k = 0; k <= j; k++) _[2] = 0;
                  } else {
                    break;
                  }
                }
              } // while
        } // vv

        return values;
      }, // _extractCombinations
      _extractSubListItems: function (lists, getListCount, getListItems, start, end) {
        var items = [];
          for (var i = 0; i < lists.length; i++) {
            var list = lists[i];
            var n = getListCount (list);
            if (n < start) {
              start -= n;
              end -= n;
            } else {
              var e = start + n;
              if (end + 1 < e) e = end + 1;
              items = items.concat (getListItems (list, start, e));
              var delta = e - start;
              start -= delta;
              end -= delta;
            }
            if (end < 0) break;
            if (start < 0) start = 0;
        }

        return items;
      }, // _extractSubListItems

      glyphClassToClassGlyphList: function (c) {
        if (!c) return null;
        if (c.cgl) return c.cgl;
        
        var classes = c.cgl = [];
          if (c.format === 1) {
            for (var i = 0; i < c.classes.length; i++) {
              var cls = c.classes[i];
              if (!classes[cls]) classes[cls] = [];
              classes[cls].push (c.startGlyph + i);
            }
          } else if (c.format === 2) {
            c.ranges.forEach (cr => {
              for (var i = cr.start; i <= cr.end; i++) {
                if (!classes[cr.classId]) classes[cr.classId] = [];
                classes[cr.classId].push (i);
              }
            });
          } // else, unknown format

        return classes;
      }, // glyphClassToClassGlyphList
      glyphClassGet: function (c, glyphID) {
        if (glyphID == null) return null;
        if (!c) return 0;
        
        if (c.format === 1) {
          return c.classes[glyphID - c.startGlyph] || 0;
        } else if (c.format === 2) {
          for (var i = 0; i < c.ranges.length; i++) {
            var cr = c.ranges[i];
            if (cr.start <= glyphID && glyphID <= cr.end) {
              return cr.classId;
            }
          }
        } // else, unknown

        return 0;
      }, // glyphClassGet

      coverageCount: function (c) {
        if (c.format === 1) {
          return c.glyphs.length;
        } else if (c.format === 2) {
          var n = 0;
          c.ranges.forEach (_ => {
            n += _.end - _.start + 1;
          });
          return n;
        } // else, unknown
        
        return 0;
      }, // coverageCount
      coverageGlyphIDs: function (c) {
        if (c.format === 1) {
          return c.glyphs.slice ();
        } else if (c.format === 2) {
          var list = [];
          c.ranges.forEach (_ => {
            for (var i = _.start; i <= _.end; i++) {
              list.push (i);
            }
          });
          return list;
        } // else, unknown
        
        return [];
      }, // coverageGlyphIDs
      coverageIndexGlyphIDs: function (c) {
        if (c.format === 1) {
          return Object.keys (c.glyphs).map (_ => [_, c.glyphs[_]]);
        } else if (c.format === 2) {
          var list = [];
          c.ranges.forEach (_ => {
            for (var i = _.start; i <= _.end; i++) {
              list.push ([i - _.start + _.index, i]);
            }
          });
          return list;
        } // else, unknown
        
        return [];
      }, // coverageIndexGlyphIDs
      coverageGet: function (c, index) {
        if (c.format === 1) {
          return c.glyphs[index]; // or undefined if bad index
        } else if (c.format === 2) {
          var x = index;
          for (var i = 0; i < c.ranges.length; i++) {
            var n = c.ranges[i].end - c.ranges[i].start + 1;
            if (x < n) {
              return c.ranges[i].start + x;
            }
            x -= n;
          }

          return undefined; // bad index
        } // else, unknown

        return undefined;
      }, // coverageGet
      coverageMatch: function (coverage, glyphID) {
        if (coverage.format === 1) {
          return coverage.glyphs.indexOf (glyphID);
        } else if (coverage.format === 2) {
          var ranges = coverage.ranges;
          for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (range.start <= glyphID && glyphID <= range.end) {
              return range.index + glyphID - range.start;
            }
          }
          return -1;
        } else { // unknown
          return -1;
        }
      }, // coverageMatch
      
      gsubLookup1: function (font, lookup, sts, glyphID) {
        for (var i = 0; i < sts.length; i++) {
        var st = sts[i];
        if (st.substFormat === 1) {
          var index = this.coverageMatch (st.coverage, glyphID);
          if (index === -1) return -1;
          return 0xFFFF & (glyphID + st.deltaGlyphId);
        } else if (st.substFormat === 2) {
          var index = this.coverageMatch (st.coverage, glyphID);
          if (index === -1) return -1;
          return st.substitute[index];
        }
        }
        return -1;
      }, // gsubLookup1
      gsubLookup2: function (font, lookup, sts, glyphID) {
        for (var i = 0; i < sts.length; i++) {
          var st = sts[i];
          if (st.substFormat === 1) {
            var index = this.coverageMatch (st.coverage, glyphID);
            if (index === -1) continue;
            return st.sequences[index].slice (); // sequence of glyph IDs
          }
        }
        return null;
      }, // gsubLookup2
      gsubLookup3: function (font, lookup, sts, glyphID) {
      for (var i = 0; i < sts.length; i++) {
        var st = sts[i];
        if (st.substFormat === 1) {
          var index = this.coverageMatch (st.coverage, glyphID);
          if (index === -1) continue;
          return st.alternateSets[index].slice (); // list of glyph IDs
        }
      }
      return null;
      }, // gsubLookup3
      gsubLookup4: function (font, lookup, sts, glyphID, ops) {
        for (var i = 0; i < sts.length; i++) {
          var st = sts[i];
          if (st.substFormat === 1) {
            var index = this.coverageMatch (st.coverage, glyphID);
            if (index === -1) continue;

            var set = st.ligatureSets[index];
            J: for (var j = 0; j < set.length; j++) {
              var lig = set[j];
              for (var k = 0; k < lig.components.length; k++) {
                var c = lig.components[k];
                var item = ops.getNextItem ();
                if (item &&
                    item.type === 'glyph' &&
                    item.glyphID === c) {
                  //
                } else {
                  ops.resetLookahead ();
                  continue J;
                }
              }
              return lig.ligGlyph;
            } // J

            // broken?
            ops.resetLookahead ();
          }
        }
        return -1;
      }, // gsubLookup4
      _gsubLookup5: function (font, lookup, sts, glyphID, ops) {
        ST: for (var i = 0; i < sts.length; i++) {
          var st = sts[i];
          ops.resetLookahead ();
          if (st.substFormat === 1 || st.posFormat === 1) {
            // XXX
          } else if (st.substFormat === 2 || st.posFormat === 2) {
            var index = this.coverageMatch (st.coverage, glyphID);
            if (index === -1) continue;

            var icd = st.classDef; // or none
            var gc = this.glyphClassGet (icd, glyphID);
            var ccs = st.classSets[gc] || [];

            K: for (var k = 0; k < ccs.length; k++) {
              var c = ccs[k];

              var itemIndex = 0;
              var glyphs = [[[glyphID], [], itemIndex++]];
              
              for (var j = 0; j < c.classes.length; j++) {
                var xGC = c.classes[j];
                var item = ops.getNextItem ();
                if (!(item && item.type === 'glyph')) continue K;
                var aGC = this.glyphClassGet (icd, item.glyphID);
                if (aGC === null || xGC !== aGC) {
                  var ignored = this._skip (font, lookup, item.glyphID);
                  if (!ignored) {
                    ops.resetLookahead ();
                    continue K;
                  } else {
                    glyphs.push ([[item.glyphID], [], -1]);
                    
                    // retry with next glyph
                    j--;
                    continue;
                  }
                } 
                
                glyphs.push ([[item.glyphID], [], itemIndex++]);
              }

              return [glyphs, c.lookupRecords];
            } // K
              
            continue;
          } else if (st.substFormat === 3 || st.posFormat === 3) {
            //XXX
          } // else, unknown
        } // ST
        return null;
      }, // _gsubLookup5
      _gsubLookup6: function (font, lookup, sts, glyphID, ops) {
        ST: for (var i = 0; i < sts.length; i++) {
          var st = sts[i];
          ops.resetLookahead ();
          if (st.substFormat === 1 || st.posFormat === 1) {
            var index = this.coverageMatch (st.coverage, glyphID);
            if (index === -1) continue;

            var ccs = st.chainRuleSets[index] || [];
            K: for (var k = 0; k < ccs.length; k++) {
              var c = ccs[k];

              var itemIndex = 0;
              var glyphs = [[[glyphID], [], itemIndex++]];
              
              for (var j = 0; j < c.input.length; j++) {
                var xG = c.input[j];
                var item = ops.getNextItem ();
                if (!(item && item.type === 'glyph')) continue K;
                if (xG !== item.glyphID) {
                  var ignored = this._skip (font, lookup, item.glyphID);
                  if (!ignored) {
                    ops.resetLookahead ();
                    continue K;
                  } else {
                    glyphs.push ([[item.glyphID], [], -1]);
                    
                    // retry with next glyph
                    j--;
                    continue;
                  }
                } 
                
                glyphs.push ([[item.glyphID], [], itemIndex++]);
              }
              ops.setSkipPoint ();
              for (var j = 0; j < c.lookahead.length; j++) {
                var xG = c.lookahead[j];
                var item = ops.getNextItem ();
                if (!(item && item.type === 'glyph')) continue K;
                if (xG !== item.glyphID) {
                  var ignored = this._skip (font, lookup, item.glyphID);
                  if (!ignored) {
                    ops.resetLookahead ();
                    continue K;
                  } else {
                    // retry with next glyph
                    j--;
                    continue;
                  }
                }
              }
              for (var j = 0; j < c.backtrack.length; j++) {
                var xG = c.backtrack[j];
                var item = ops.getPrevItem ();
                if (!(item && item.type === 'glyph')) continue K;
                if (xG !== item.glyphID) {
                  var ignored = this._skip (font, lookup, item.glyphID);
                  if (!ignored) {
                    ops.resetLookahead ();
                    continue K;
                  } else {
                    // retry with previous glyph
                    j--;
                    continue;
                  }
                }
              }

              return [glyphs, c.lookupRecords];
            } // K

            continue;
          } else if (st.substFormat === 2 || st.posFormat === 2) {
            var index = this.coverageMatch (st.coverage, glyphID);
            if (index === -1) continue;

            var bcd = st.backtrackClassDef; // or none
            var icd = st.inputClassDef; // or none
            var lcd = st.lookaheadClassDef; // or none
            var gc = this.glyphClassGet (icd, glyphID);
            var ccs = st.chainClassSet[gc] || [];

            K: for (var k = 0; k < ccs.length; k++) {
              var c = ccs[k];

              var itemIndex = 0;
              var glyphs = [[[glyphID], [], itemIndex++]];
              
              for (var j = 0; j < c.input.length; j++) {
                var xGC = c.input[j];
                var item = ops.getNextItem ();
                if (!(item && item.type === 'glyph')) continue K;
                var aGC = this.glyphClassGet (icd, item.glyphID);
                if (aGC === null || xGC !== aGC) {
                  var ignored = this._skip (font, lookup, item.glyphID);
                  if (!ignored) {
                    ops.resetLookahead ();
                    continue K;
                  } else {
                    glyphs.push ([[item.glyphID], [], -1]);
                    
                    // retry with next glyph
                    j--;
                    continue;
                  }
                } 
                
                glyphs.push ([[item.glyphID], [], itemIndex++]);
              }
              ops.setSkipPoint ();
              for (var j = 0; j < c.lookahead.length; j++) {
                var xGC = c.lookahead[j];
                var item = ops.getNextItem ();
                if (!(item && item.type === 'glyph')) continue K;
                var aGC = this.glyphClassGet (lcd, item.glyphID);
                if (aGC === null || xGC !== aGC) {
                  var ignored = this._skip (font, lookup, item.glyphID);
                  if (!ignored) {
                    ops.resetLookahead ();
                    continue K;
                  } else {
                    // retry with next glyph
                    j--;
                    continue;
                  }
                }
              }
              for (var j = 0; j < c.backtrack.length; j++) {
                var xGC = c.backtrack[j];
                var item = ops.getPrevItem ();
                if (!(item && item.type === 'glyph')) continue K;
                var aGC = this.glyphClassGet (bcd, item.glyphID);
                if (aGC === null || xGC !== aGC) {
                  var ignored = this._skip (font, lookup, item.glyphID);
                  if (!ignored) {
                    ops.resetLookahead ();
                    continue K;
                  } else {
                    // retry with previous glyph
                    j--;
                    continue;
                  }
                }
              }

              return [glyphs, c.lookupRecords];
            } // K
              
            continue;
          } else if (st.substFormat === 3 || st.posFormat === 3) {
            if (!st.inputCoverage.length) continue ST; // broken?
            var itemIndex = 0;
            var glyphs = [[[glyphID], [], itemIndex++]];
            var index = this.coverageMatch (st.inputCoverage[0], glyphID);
            if (index === -1) continue ST;
            for (var i = 1; i < st.inputCoverage.length; i++) {
              var item = ops.getNextItem ();
              if (!(item && item.type === 'glyph')) continue ST;
              var index = this.coverageMatch (st.inputCoverage[i], item.glyphID);
              if (index === -1) continue ST;
              glyphs.push ([[item.glyphID], [], itemIndex++]);
            }
            ops.setSkipPoint ();
            for (var i = 0; i < st.lookaheadCoverage.length; i++) {
              var item = ops.getNextItem ();
              if (!(item && item.type === 'glyph')) continue ST;
              var index = this.coverageMatch (st.lookaheadCoverage[i], item.glyphID);
              if (index === -1) continue ST;
            }
            for (var i = 0; i < st.backtrackCoverage.length; i++) {
              var item = ops.getPrevItem ();
              if (!(item && item.type === 'glyph')) continue ST;
              var index = this.coverageMatch (st.backtrackCoverage[i], item.glyphID);
              if (index === -1) continue ST;
            }

            return [glyphs, st.lookupRecords];
          } // else, unknown
        } // ST
        return null;
      }, // _gsubLookup6
      gsubLookup5: function (font, lookup, sts, glyphID, ops) {
        var x = this._gsubLookup5 (font, lookup, sts, glyphID, ops);
        if (!x) return [];

        this._applyGSUBLookupRecords (font, x[1], x[0]);
        return x[0];
      },
      gsubLookup6: function (font, lookup, sts, glyphID, ops) {
        var x = this._gsubLookup6 (font, lookup, sts, glyphID, ops);
        if (!x) return [];

        this._applyGSUBLookupRecords (font, x[1], x[0]);
        return x[0];
      },
      gposLookup1: function (font, lookup, sts, glyphID, ops) {
        ST: for (var i = 0; i < sts.length; i++) {
          var st = sts[i];
          if (st.posFormat === 1) {
            var index = this.coverageMatch (st.coverage, glyphID);
            if (index === -1) continue;

            return {
              value: st.value,
            };
          } else if (st.posFormat === 2) {
            var index = this.coverageMatch (st.coverage, glyphID);
            if (index === -1) continue;

            return {
              value: st.values[index],
            };
          } // else, unknown
        } // ST

        return null;
      }, // gposLookup1
      gposLookup2: function (font, lookup, sts, glyphID, ops) {
        ST: for (var i = 0; i < sts.length; i++) {
          var st = sts[i];
          ops.resetLookahead ();
          if (st.posFormat === 1) {
            //
          } else if (st.posFormat === 2) {
            var index = this.coverageMatch (st.coverage, glyphID);
            if (index === -1) continue;
            var c1 = this.glyphClassGet (st.classDef1, glyphID) || 0;

            var item = ops.getNextItem ();
            if (!(item && item.type === 'glyph')) continue;
            var c2 = this.glyphClassGet (st.classDef2, item.glyphID) || 0;

            var cr = (st.classRecords[c1] || [])[c2] || {};
            var v1 = {
              value: cr.value1,
            };
            var v2 = {
              value: cr.value2,
            };
            return [v1, v2];
          } // else, unknown
        } // ST

        return null;
      }, // gposLookup2
      gposLookup3: function (font, lookup, sts, glyphID, ops) {
        ST: for (var i = 0; i < sts.length; i++) {
          var st = sts[i];
          if (st.posFormat === 1) {
            var index = this.coverageMatch (st.coverage, glyphID);
            if (index === -1) continue;

            // {entryAnchor, exitAnchor}
            var ee = st.entryExits[index] || {};
            return {
              entryAnchor: ee.entryAnchor,
              exitAnchor: ee.exitAnchor,
              rtl: (lookup.lookupFlag & 0b1),
            };
          } // else, unknown
        } // ST

        return null;
      }, // gposLookup3
      gposLookup4: function (font, lookup, sts, glyphID, ops) {
        ST: for (var i = 0; i < sts.length; i++) {
          var st = sts[i];
          ops.resetLookahead ();
          if (st.posFormat === 1) {
            var bc = this.coverageMatch (st.markCoverage, glyphID);
            if (bc === -1) continue;

            var item = ops.getPrevItem ();
            if (!(item && item.type === 'glyph')) continue;
            var mc = this.coverageMatch (st.baseCoverage, item.glyphID);
            if (mc === -1) continue;
            //XXX ignore?

            var mark = st.marks[mc]; // or undefined 
            var base = ((st.bases[bc] || {}).baseAnchors || [])[mark.markClass]; // or undefined
            
            var v1 = {
              anchor: base,
            };
            var v2 = {
              anchor: mark.markAnchor,
            };
            //XXX xref v1 - v2
            return [v1, v2];
          } // else, unknown
        } // ST

        return null;
      }, // gposLookup4
      gposLookup6: function (font, lookup, sts, glyphID, ops) {
        ST: for (var i = 0; i < sts.length; i++) {
          var st = sts[i];
          ops.resetLookahead ();
          if (st.posFormat === 1) {
            var bc = this.coverageMatch (st.mark1Coverage, glyphID);
            if (bc === -1) continue;

            var item = ops.getPrevItem ();
            if (!(item && item.type === 'glyph')) continue;
            var mc = this.coverageMatch (st.mark2Coverage, item.glyphID);
            if (mc === -1) continue;
            //XXX ignore?

            var mark = st.mark1s[mc] || {};
            var base = ((st.mark2s[bc] || {}).mark2Anchors || [])[mark.markClass] || {};
            
            var v1 = {
              anchor: base,
            };
            var v2 = {
              anchor: mark.markAnchor,
            };
            //XXX xref v1 - v2
            return [v1, v2];
          } // else, unknown
        } // ST

        return null;
      }, // gposLookup6
      gposLookup7: function (font, lookup, sts, glyphID, ops) {
        var x = this._gsubLookup5 (font, lookup, sts, glyphID, ops);
        //[glyphs, lookupRecords]
        if (!x) return null;

        this._applyGPOSLookupRecords (font, x[1], x[0]);
        return x[0].map (_ => _[3]).flat ();
      },
      gposLookup8: function (font, lookup, sts, glyphID, ops) {
        var x = this._gsubLookup6 (font, lookup, sts, glyphID, ops);
        //[glyphs, lookupRecords]
        if (!x) return null;

        this._applyGPOSLookupRecords (font, x[1], x[0]);
        return x[0].map (_ => _[3]).flat ();
      },
      _skip: function (font, lookup, glyphID) {
        var ignored = false;
        if (lookup.lookupFlag & 0b1111111100011110) {
          var gcd = (font.tables.gdef || {}).classDef; // or none
          var mcd = (font.tables.gdef || {}).markAttachClassDef; // or none
          var mgs = (font.tables.gdef || {}).markGlyphSets || [];
          var gc = this.glyphClassGet (gcd, glyphID);
          if (gc === 3 /* mark */) {
            if (lookup.lookupFlag & 0b1000) {
              ignored = true;
            } else if (lookup.lookupFlag & 0b10000) {
              var mfs = lookup.markFilteringSet || 0;
              var matched = false;
              var max = Math.max (mgs.length, 16);
              for (var x = 0; x < max; x++) {
                if (mfs & (1 << x)) {
                  var index = this.coverageMatch (mgs[x], glyphID);
                  if (index === -1) continue;
                  matched = true;
                  break;
                }
              }
              if (!matched) ignored = true;
            } else {
              var type = lookup.lookupFlag >> 8;
              if (type) {
                var mc = this.glyphClassGet (mcd, glyphID);
                if (mc !== type) ignored = true;
              }
            }
          } else if (gcd === 2 && lookup.lookupFlag & 0b100) {
            ignored = true;
          } else if (gcd === 1 && lookup.lookupFlag & 0b10) {
            ignored = true;
          }
        }
        return ignored;
      }, // _skip
      _applyGSUBLookupRecords: function (font, lrs, glyphs) {
        var indexToGlyph = [];
        glyphs.forEach (_ => indexToGlyph[_[2]] = _);
        lrs.forEach (lr => {
          var g = indexToGlyph[lr.sequenceIndex];
          if (!g) return; // broken

          var lookup = (font.tables.gsub || {lookups: []}).lookups[lr.lookupListIndex];
          if (!lookup) return; // broken

          if (lookup.lookupType === 1) {
            g[0] = g[0].map (glyphID => {
              var newID = OT.gsubLookup1 (font, lookup, lookup.subtables, glyphID);
              if (newID === -1) return glyphID; // unchanged (broken?)

              return newID;
            });
            g[1].push (lookup);
          } else if (lookup.lookupType === 2) {
            g[0] = g[0].map (glyphID => {
              var newIDs = OT.gsubLookup2 (font, lookup, lookup.subtables, glyphID);
              if (!newIDs.length) return [glyphID]; // unchanged (broken?)
              
              return newIDs;
            }).flat ();
            g[1].push (lookup);
          } else if (lookup.lookupType === 4) {
            var newIDs = [];
            for (var i = 0; i < g[0].length; i++) {
              var j = i;
              var k = 0;
              var ref = [lr.sequenceIndex, i];
              var skipRef;
              var ops = {
                getNextItem: () => {
                  if (!indexToGlyph[ref[0]]) return null;
                  
                  ref[1]++;
                  if (indexToGlyph[ref[0]][0].length === ref[1]) {
                    ref[0]++;
                    ref[1] = 0;
                  }
                  var x = ((indexToGlyph[ref[0]] || [])[0] || [])[ref[1]];
                  if (x != null) return {type: 'glyph', glyphID: x};
                  return null;
                },
                setSkipPoint: () => skipRef = ref,
                resetLookahead: () => {
                  ref = [lr.sequenceIndex, i];
                  skipRef = null;
                },
              };
              var newID = OT.gsubLookup4 (font, lookup, lookup.subtables, g[0][i], ops);
              if (newID !== -1) {
                newIDs.push (newID);
                skipRef = skipRef || ref;
                if (skipRef[0] > lr.sequenceIndex) {
                  for (var j = lr.sequenceIndex + 1; j <= skipRef[0] - 1; j++) {
                    indexToGlyph[j][0] = [];
                  }
                  indexToGlyph[skipRef[0]][0].splice (0, skipRef[1] + 1);
                  break;
                } else {
                  i = skipRef[1];
                }
              } else {
                newIDs.push (g[0][i]); // unchanged (broken?)
              }
            } // i
            g[0] = newIDs;
          } // else, not supported
        });
      }, // _applyGSUBLookupRecords
      _applyGPOSLookupRecords: function (font, lrs, glyphs) {
        var indexToGlyph = [];
        glyphs.forEach (_ => indexToGlyph[_[2]] = _);
        lrs.forEach (lr => {
          var g = indexToGlyph[lr.sequenceIndex];
          if (!g) return; // broken

          var lookup = (font.tables.gpos || {lookups: []}).lookups[lr.lookupListIndex];
          if (!lookup) return; // broken

          if (lookup.lookupType === 1) {
            g[3] = g[0].map (glyphID => {
              var r = OT.gposLookup1 (font, lookup, lookup.subtables, glyphID);
              if (!r) return {}; // broken?

              return r;
            });
            g[1].push (lookup);
          } // else, not supported
        });
      }, // _applyGPOSLookupRecords

      _ic0: function (sub) {
        if (sub._ic0) return sub._ic0;

        var ic = this.glyphClassToClassGlyphList
            (sub.inputClassDef /* GSUB 6 */ || sub.classDef /* GSUB 5 */ ||
             sub.classDef1 /* GPOS 2 */) || [];
        var bc = this.glyphClassToClassGlyphList (sub.backtrackClassDef) || []; // 6 only
        var lc = this.glyphClassToClassGlyphList (sub.lookaheadClassDef) || []; // 6 only

        var ic0 = sub._ic0 = ic.map (_ => []);
        this.coverageGlyphIDs (sub.coverage).forEach (glyphID => {
          for (var i = 0; i < ic.length; i++) {
            if (ic[i] && ic[i].indexOf (glyphID) >= 0) {
              ic0[i].push (glyphID);
              break;
            }
          }
        });

        Object.keys (ic0).forEach (ic0Class => {
          var m = 0;
          var l = (sub.chainClassSet /* GSUB 6 */ ||
                   sub.classSets /* GSUB 5 */ ||
                   sub.classRecords /* GPOS 2 */)[ic0Class] || [];
          l.forEach (c => {
            var n = ic0[ic0Class].length;
            (c.input /* 6 */ || c.classes /* 6 */ || []).forEach (j => {
              n *= ic[j].length;
            });
            (c.backtrack /* 6 */ || []).forEach (j => {
              n *= bc[j].length;
            });
            (c.lookahead /* 6 */ || []).forEach (j => {
              n *= lc[j].length;
            });

            c.listItemCount = n;
            m += n;
            // This is not strict, since l[1] might have duplicate with l[0]
          });
          ic0[ic0Class].listItemCount = m;
        }); // ic0Class

        return ic0;
      }, // _ic0
      gsubLookupSubtableCount: function (lookup, sub) {
        if (lookup.lookupType === 7 && sub.extension) {
          lookup = {lookupType: sub.lookupType};
          sub = sub.extension;
        }

        if (lookup.lookupType === 5 &&
            sub.substFormat === 2) {
          var ic0 = this._ic0 (sub);

          var m = 0;
          Object.keys (ic0).forEach (_ => m += ic0[_].listItemCount);
          return m;
        } else if (lookup.lookupType === 6 &&
                   sub.substFormat === 1) {
          //var n = this.coverageCount (sub.coverage);
          var m = 0;
          (sub.chainRuleSets || []).forEach (_ => {
            m += _.length;
          });
          return m;
        } else if (lookup.lookupType === 6 &&
                   sub.substFormat === 2) {
          var ic0 = this._ic0 (sub);

          var m = 0;
          Object.keys (ic0).forEach (_ => m += ic0[_].listItemCount);
          return m;
        } else if (lookup.lookupType === 6 &&
                   sub.substFormat === 3) {
          var n = 1;
          sub.backtrackCoverage.forEach (c => {
            n *= this.coverageCount (c);
          });
          sub.inputCoverage.forEach (c => {
            n *= this.coverageCount (c);
          });
          sub.lookaheadCoverage.forEach (c => {
            n *= this.coverageCount (c);
          });
          return n;
        } else if (sub.coverage) {
          return this.coverageCount (sub.coverage);
        }

        return 0;
      }, // gsubLookupSubtableCount
      _lookupSubtableItems: function (lookup, sub, page) {
        if (lookup.lookupType === 5 /* GSUB */ ||
            lookup.lookupType === 7 /* GPOS */) {
          if (sub.substFormat === 1 || sub.posFormat === 1) {
            //XXX
          } else if (sub.substFormat === 2 || sub.posFormat === 2) {
            var ic = this.glyphClassToClassGlyphList (sub.classDef) || [];
            var ic0 = this._ic0 (sub);

            var getListCount = _ => {
              return _[1].listItemCount;
            };
            var getListItems = (_, start, e) => {
              var ic0Class = _[0];
              var c = _[1];
              
              var xx = 
                  ([ [[null, null] /* ic0 */, 0] ]).concat
                  (c.classes.map (_ => [[ic, _], 0]));
              var cCount = x => {
                if (x[0]) {
                  return x[0][x[1]].length;
                } else {
                  return ic0[ic0Class].length;
                }
              };

              var values = this._extractCombinations
                    (xx, cCount, page.start, page.end);
              
              return values.map (w => {
                w = w.map (([x, index, position]) => {
                  if (x[0]) {
                    return {glyphID: x[0][x[1]][index], position};
                  } else {
                    return {glyphID: ic0[ic0Class][index], position};
                  }
                });
                return {
                  srcGlyphs: w,
                  _lrs: c.lookupRecords,
                };
              });
            };

            var xx = Object.keys (ic0).map (ic0Class => (sub.classSets[ic0Class] || []).map (_ => [ic0Class, _])).flat ();
            var items = this._extractSubListItems
                (xx, getListCount, getListItems, page.start, page.end);

            return items;
          } else if (sub.substFormat === 3 || sub.posFormat === 3) {
            // XXX
          } // else, unknown
        } else if (lookup.lookupType === 6 /* GSUB */ ||
                   lookup.lookupType === 8 /* GPOS */) {
          if (sub.substFormat === 1 || sub.posFormat === 1) {
            var items = this.coverageGlyphIDs (sub.coverage);
            var values = [];
            for (var i = 0; i < items.length; i++) {
              var rs = sub.chainRuleSets[i];
              if (!rs) continue;
              rs.forEach (_ => {
                var glyphs = _.backtrack.map (_ => {
                  return {glyphID: _, position: -1};
                });
                glyphs = glyphs.concat ([items[i]].concat (_.input).map (_ => {
                  return {glyphID: _, position: 0};
                }));
                glyphs = glyphs.concat (_.lookahead.map (_ => {
                  return {glyphID: _, position: +1};
                }));
                values.push ({
                  srcGlyphs: glyphs,
                  _lrs: _.lookupRecords
                });
              });
            }
            
            return values.slice (page.start, page.end + 1);
          } else if (sub.substFormat === 2 || sub.posFormat === 2) {
            var bc = this.glyphClassToClassGlyphList (sub.backtrackClassDef) || [];
            var ic = this.glyphClassToClassGlyphList (sub.inputClassDef) || [];
            var lc = this.glyphClassToClassGlyphList (sub.lookaheadClassDef) || [];

            var ic0 = this._ic0 (sub);

            var getListCount = _ => {
              return _[1].listItemCount;
            };
            var getListItems = (_, start, e) => {
              var ic0Class = _[0];
              var c = _[1];
              
              var xx = c.backtrack.map (_ => [[bc, _], -1]).reverse ().concat
                  ([ [[null, null] /* ic0 */, 0] ]).concat
                  (c.input.map (_ => [[ic, _], 0])).concat
                  (c.lookahead.map (_ => [[lc, _], +1]));
              var cCount = x => {
                if (x[0]) {
                  return x[0][x[1]].length;
                } else {
                  return ic0[ic0Class].length;
                }
              };

              var values = this._extractCombinations
                    (xx, cCount, page.start, page.end);
              
              return values.map (w => {
                w = w.map (([x, index, position]) => {
                  if (x[0]) {
                    return {glyphID: x[0][x[1]][index], position};
                  } else {
                    return {glyphID: ic0[ic0Class][index], position};
                  }
                });
                return {
                  srcGlyphs: w,
                  _lrs: c.lookupRecords,
                };
              });
            };

            var xx = Object.keys (ic0).map (ic0Class => (sub.chainClassSet[ic0Class] || []).map (_ => [ic0Class, _])).flat ();
            var items = this._extractSubListItems
                (xx, getListCount, getListItems, page.start, page.end);

            return items;
          } else if (sub.substFormat === 3 || sub.posFormat === 3) {
            var xx = sub.backtrackCoverage.map (_ => [_, -1]).reverse ().concat
                (sub.inputCoverage.map (_ => [_, 0])).concat
                (sub.lookaheadCoverage.map (_ => [_, +1]));
            var cCount = c => this.coverageCount (c);

            var values = this._extractCombinations
                (xx, cCount, page.start, page.end);

            var items = values.map (w => {
              w = w.map (([c, index, position]) => {
                return {glyphID: this.coverageGet (c, index), position};
              });
              return {
                srcGlyphs: w,
                _lrs: sub.lookupRecords,
              };
            });

            return items;
          } // substFormat
        }
        
        return null; // unknown
      }, // _lookupSubtableItems
      gsubLookupSubtableItems: function (font, lookup, sub, page) {
        if (lookup.lookupType === 7 && sub.extension) {
          lookup = {lookupType: sub.lookupType};
          sub = sub.extension;
        }
        
        if (lookup.lookupType === 5 ||
            lookup.lookupType === 6) {
          var items = this._lookupSubtableItems (lookup, sub, page);
          if (items) return this._nestedGSUBLookupItems (font, items);
        } else if (lookup.lookupType === 8) {
          //XXX
        }

        var c = sub.coverage;
        if (!c) return []; // unknown
        var items = [];
          
        if (c.format === 1) {
          var i = 0;
            items = c.glyphs.slice (page.start, page.end + 1).map (_ => {
              return {
                srcGlyphs: [{glyphID: _}],
                index: page.start + i++,
              };
            });
        } else if (c.format === 2) {
          var getListCount = range => range.end - range.start + 1;
          var getListItems = (range, start, e) => {
            var items = [];
            for (var j = start; j < e; j++) {
              var srcGlyphID = range.start + j;
              var index = range.index + srcGlyphID - range.start;
              items.push ({
                srcGlyphs: [{glyphID: srcGlyphID}],
                index,
              });
            }
            return items;
          };
          items = this._extractSubListItems (c.ranges, getListCount, getListItems, page.start, page.end);
        } // c

        if (lookup.lookupType === 1) {
          if (sub.substFormat === 1) {
              items.forEach (item => {
                item.glyphs = [{glyphID: 0xFFFF & (item.srcGlyphs[0].glyphID + sub.deltaGlyphId)}];
              });
          } else if (sub.substFormat === 2) {
              items.forEach (item => {
                item.glyphs = [{glyphID: sub.substitute[item.index]}];
              });
            }
        } else if (lookup.lookupType === 2) {
            if (sub.substFormat === 1) {
              items.forEach (item => {
                item.glyphs = sub.sequences[item.index].map (_ => {
                  return {glyphID: _};
                });
              });
            }
        } else if (lookup.lookupType === 3) {
          if (sub.substFormat === 1) {
            items = items.map (item => {
              return sub.alternateSets[item.index].map (_ => {
                var newItem = {};
                for (var n in item) newItem[n] = item[n];
                
                newItem.glyphs = [{glyphID: _}];
                
                return newItem;
              });
            }).flat ();
          } // else, unknown
        } else if (lookup.lookupType === 4) {
          if (sub.substFormat === 1) {
            items = items.map (item => {
              if (item.index === -1) {
                item.glyphs = [];
                return item;
              } else {
                return sub.ligatureSets[item.index].map (lig => {
                  var newItem = {};
                  for (var n in item) newItem[n] = item[n]; 
                  
                  newItem.srcGlyphs = item.srcGlyphs.concat (lig.components.map (_ => {
                    return {
                      glyphID: _,
                    };
                  }));
                  newItem.glyphs = [{glyphID: lig.ligGlyph}];
                  
                  return newItem;
                });
              }
            }).flat ();
          }
        } //else, unknown

        return items;
      }, // gsubLookupSubtableItems
      gposLookupSubtableCount: function (lookup, st) {
        if (lookup.lookupType === 9 && st.extension) {
          lookup = {lookupType: st.extensionLookupType};
          st = st.extension;
        }
        
        if (lookup.lookupType === 2 && st.posFormat === 2) {
          var ic0 = this._ic0 (st);
          var c2 = this.glyphClassToClassGlyphList (st.classDef2) || [];
          if (!c2[0]) c2[0] = [];
          if (!c2[0].length) c2[0].push (-100);
          var ic0f = Object.values (ic0).flat ();
          var c2f = Object.values (c2).flat ();

          return ic0f.length * c2f.length;
        } else if (lookup.lookupType === 4 && st.posFormat === 1) {
          var cb = this.coverageCount (st.baseCoverage);
          var cm = this.coverageCount (st.markCoverage);
          return cb * cm;
        } else if (lookup.lookupType === 6 && st.posFormat === 1) {
          var cb = this.coverageCount (st.mark2Coverage);
          var cm = this.coverageCount (st.mark1Coverage);
          return cb * cm;

        } else if (lookup.lookupType === 7 &&
                   st.posFormat === 2) {
          var ic0 = this._ic0 (st);

          var m = 0;
          Object.keys (ic0).forEach (_ => m += ic0[_].listItemCount);
          return m;
        } else if (lookup.lookupType === 8 &&
                   st.posFormat === 1) {
          //var n = this.coverageCount (st.coverage);
          var m = 0;
          (st.chainRuleSets || []).forEach (_ => {
            m += _.length;
          });
          return m;
        } else if (lookup.lookupType === 8 &&
                   st.posFormat === 2) {
          var ic0 = this._ic0 (st);

          var m = 0;
          Object.keys (ic0).forEach (_ => m += ic0[_].listItemCount);
          return m;
        } else if (lookup.lookupType === 8 &&
                   st.posFormat === 3) {
          var n = 1;
          st.backtrackCoverage.forEach (c => {
            n *= this.coverageCount (c);
          });
          st.inputCoverage.forEach (c => {
            n *= this.coverageCount (c);
          });
          st.lookaheadCoverage.forEach (c => {
            n *= this.coverageCount (c);
          });
          return n;
        } // lookupType: else, unknown
        
        return this.coverageCount (st.coverage) || 0;
      }, // gposLookupSubtableCount
      gposLookupSubtableItems: function (font, lookup, st, page) {
        if (lookup.lookupType === 9 && st.extension) {
          lookup = {lookupType: st.extensionLookupType};
          st = st.extension;
        }
        
        if (lookup.lookupType === 1 && st.posFormat === 1) {
          return this.coverageGlyphIDs (st.coverage).slice (page.start, page.end + 1).map (_ => {
            return {
              glyphs: [{glyphID: _}],
              values: [{value: st.value}],
            };
          });
        } else if (lookup.lookupType === 1 && st.posFormat === 2) {
          return this.coverageIndexGlyphIDs (st.coverage).slice (page.start, page.end + 1).map (_ => {
            return {
              glyphs: [{glyphID: _[1]}],
              values: [{value: st.values[_[0]]}],
            };
          });
        } else if (lookup.lookupType === 2 && st.posFormat === 1) {
          return this.coverageIndexGlyphIDs (st.coverage).slice (page.start, page.end + 1).map (([index1, glyphID1]) => {
            return items = st.pairSets[index1].map (_ => {
              return {
                glyphs: [{glyphID: glyphID1}, {glyphID: _.secondGlyph}],
                values: [{value: _.value1}, {value: _.value2}],
              };
            });
          }).flat ();
        } else if (lookup.lookupType === 2 && st.posFormat === 2) {
          var ic0 = this._ic0 (st);
          var c2 = this.glyphClassToClassGlyphList (st.classDef2) || [];
          if (!c2[0]) c2[0] = [];
          if (!c2[0].length) c2[0].push (-100);
          var ic0f = Object.values (ic0).flat ();
          var c2f = Object.values (c2).flat ();
          var cls1 = {};
          Object.keys (ic0).forEach (c => ic0[c].forEach (g => cls1[g] = c));
          var cls2 = {};
          Object.keys (c2).forEach (c => c2[c].forEach (g => cls2[g] = c));

          var xx = [
            [ic0f, 0],
            [c2f, 0],
          ];
          var cCount = c => c.length;
          var values = this._extractCombinations
              (xx, cCount, page.start, page.end);

          return values.map (w => {
            w = w.map (([x, index, position]) => {
              return {glyphID: x[index]};
            });

            var cr = st.classRecords[cls1[w[0].glyphID]][cls2[w[1].glyphID]] || {};
            return {
              glyphs: w,
              values: [{value: cr.value1}, {value: cr.value2}],
            };
          });
        } else if (lookup.lookupType === 3 && st.posFormat === 1) {
          return this.coverageIndexGlyphIDs (st.coverage).slice (page.start, page.end + 1).map (_ => {
            var ee = st.entryExits[_[0]];
            return {
              glyphs: [{glyphID: _[1]}],
              values: [{
                entryAnchor: ee.entryAnchor,
                exitAnchor: ee.exitAnchor,
                rtl: (lookup.lookupFlag & 0b1),
              }],
            };
          });
        } else if (lookup.lookupType === 4 && st.posFormat === 1) {
          var xx = [
            [st.baseCoverage, 0],
            [st.markCoverage, 0],
          ];
          var cCount = c => this.coverageCount (c);
          var values = this._extractCombinations
              (xx, cCount, page.start, page.end);

          return values.map (w => {
            w = w.map (([x, index, position]) => {
              return {glyphID: this.coverageGet (x, index)};
            });

            var bc = this.coverageMatch (st.baseCoverage, w[0].glyphID);
            var mc = this.coverageMatch (st.markCoverage, w[1].glyphID);
            var mark = st.marks[mc]; // or undefined
            var base = ((st.bases[bc] || {}).baseAnchors || [])[mark.markClass]; // or undefined
            
            return {
              glyphs: w,
              values: [{anchor: base}, {anchor: mark.markAnchor}],
            };
          });
        } else if (lookup.lookupType === 6 && st.posFormat === 1) {
          var xx = [
            [st.mark2Coverage, 0],
            [st.mark1Coverage, 0],
          ];
          var cCount = c => this.coverageCount (c);
          var values = this._extractCombinations
              (xx, cCount, page.start, page.end);

          return values.map (w => {
            w = w.map (([x, index, position]) => {
              return {glyphID: this.coverageGet (x, index)};
            });

            var bc = this.coverageMatch (st.mark2Coverage, w[0].glyphID);
            var mc = this.coverageMatch (st.mark1Coverage, w[1].glyphID);
            var mark = st.mark1s[mc] || {};
            var base = ((st.mark2s[bc] || {}).mark2Anchors || [])[mark.markClass] || {};
            
            return {
              glyphs: w,
              values: [{anchor: base}, {anchor: mark.markAnchor}],
            };
          });
        } else if (lookup.lookupType === 7 ||
                   lookup.lookupType === 8) {
          var items = this._lookupSubtableItems (lookup, st, page);
          if (items) return this._nestedGPOSLookupItems (font, items);
        } // lookupType: else, unknown

        return [];
      }, // gposLookupSubtableItems
      _nestedGSUBLookupItems: function (font, items) {
        items.forEach (item => {
          var index = 0;
          for (var i = 0; i < item.srcGlyphs.length; i++) {
            var p = item.srcGlyphs[i].position;
            if (p === 0) {
              item.srcGlyphs[i].index = index++;
            }
          }

          var glyphs = item.srcGlyphs.map (_ => {
            return [[_.glyphID], [], _.index];
          });
          this._applyGSUBLookupRecords (font, item._lrs, glyphs);
          item.glyphs = glyphs.map (_ => {
            return _[0].map (_ => {
              return {
                glyphID: _,
                //position,
              };
            });
          }).flat ();
        });

        return items;
      }, // _nestedGSUBLookupItems
      _nestedGPOSLookupItems: function (font, items) {
        items.forEach (item => {
          var index = 0;
          for (var i = 0; i < item.srcGlyphs.length; i++) {
            var p = item.srcGlyphs[i].position;
            if (p === 0) {
              item.srcGlyphs[i].index = index++;
            }
          }

          var glyphs = item.srcGlyphs.map (_ => {
            return [[_.glyphID], [], _.index, [{}]];
          });
          this._applyGPOSLookupRecords (font, item._lrs, glyphs);
          item.glyphs = item.srcGlyphs;
          item.values = glyphs.map (_ => _[3]).flat ();
        });

        return items;
      }, // _nestedGPOSLookupItems

      getGlyph: function (font, glyphID) {
        if (glyphID < 0) return null;
        var glyph = font.glyphs.get (glyphID);
        var gm = glyph.getMetrics ();
        glyph.metrics = gm;
        return glyph;
      }, // getGlyph
      
    }; // OT

    var bitFields = (obj, name, bits) => {
      for (var i = 0; i < bits; i++) {
        var n = 1 << i;
        obj[name + '-' + i] = obj[name] & n ? '' : undefined;
      }
    }; // bitFields

    var uniq = list => {
      var found = {};
      return list.filter (_ => (found[_] = (found[_] || 0) + 1) < 2);
    };

    defineElement ({
      name: 'font-viewer',
      props: {
        pcInit: function () {
          this.loading = 0;
          this.nextId = 0;

          //XXX if query,
          //this.loadByURL ('...', {});

          window.onhashchange = ev => {
            var m = location.hash.match (/^#(font-[0-9]+)-glyph-([0-9]+)$/);
            if (m) {
              var s = this.querySelector ('#' + m[1]);
              if (s) {
                s.querySelector ('glyph-data').show (parseInt (m[2]), {
                  scroll: true,
                });
              } else {
                console.log ("Font not loaded: " + location.hash);
              }
            }
          };
        }, // pcInit

        loadByURL: async function (url, opts) {
          return await this._load (async () => {
            return await opentype.load (url);
          }, opts);
        }, // loadByURL
        loadByBlob: async function (blob, opts) {
          return await this._load (async () => {
            var ab = await blob.arrayBuffer ();
            return opentype.parse (ab, {});
            this._initFont (font);
          }, opts);
        }, // loadByBlob
        _load: function (code, opts) {
          this.loading++;
          this.querySelectorAll ('tab-menu-extras progress').forEach (_ => _.hidden = false);
          var logs = this.querySelector ('tab-set > section:first-of-type .logs');
          var log = document.createElement ('li');
          logs.appendChild (log);
          var addLog = (msg) => {
            var p = document.createElement ('p');
            p.textContent = msg;
            log.appendChild (p);
          };
          var times = {};
          times.start = performance.now ();
          return Promise.resolve ().then (code).then (font => {
            times.parsed = performance.now ();
            addLog ((font.names.fullName || font.names.fontFamily || {}).en);
            addLog ('parse: ' + (times.parsed - times.start));
            this._initFont (font);
            times.inited = performance.now ();
            addLog ('init: ' + (times.inited - times.parsed));

            var id = 'font-' + this.nextId++;
            var container = this.querySelector ('tab-set');
            this._showFont (container, font, id);
            times.shown = performance.now ();
            addLog ('show: ' + (times.shown - times.inited));
            history.replaceState (null, null, '#' + id);
          }).finally (() => {
            this.loading--;
            if (this.loading <= 0) this.querySelectorAll ('tab-menu-extras progress').forEach (_ => _.hidden = true);
          });
        }, // _load
        
        _initFont: function (font) {
  bitFields (font.tables.head, 'flags', 16);
  bitFields (font.tables.head, 'macStyle', 16);
  bitFields (font.tables.os2, 'fsType', 16);

  font.tables.os2['fsType-0'] = font.tables.os2.fsType & 0b1111;
  font.tables.os2['sFamilyClass-classID'] = font.tables.os2.sFamilyClass >> 8;
  font.tables.os2['sFamilyClass-subclassID'] = font.tables.os2.sFamilyClass & 255;
  font.tables.os2['sFamilyClass-classID-subclassID']
      = font.tables.os2['sFamilyClass-classID'] + '-' +
        font.tables.os2['sFamilyClass-subclassID'];

  var i = 0;
  font.tables.cmap.subtables.forEach (c => {
    c.parse();
    c.index = i++;
    c.peID = (c.platformID === 4 ? c.encodingID : c.platformID + '-' + c.encodingID);
    if (c.language) c.languageID = c.language - 1;
    if (c.language === 0) c.languageID = null;

    c.glyphNumber = 0;
    if (c.glyphIndexMap || c.varGlyphIndexMap) {
      if (c.glyphIndexMap) c.glyphNumber += Object.keys (c.glyphIndexMap).length;
      (c.varGlyphIndexMap || []).forEach (v => {
        c.glyphNumber += Object.keys (v).length;
      });
    }
  });

  bitFields (font.tables.os2, 'ulUnicodeRange1', 32);
  bitFields (font.tables.os2, 'ulUnicodeRange2', 32);
  bitFields (font.tables.os2, 'ulUnicodeRange3', 32);
  bitFields (font.tables.os2, 'ulUnicodeRange4', 32);
  bitFields (font.tables.os2, 'fsSelection', 16);

  font.glyphNameToID = {};
  Object.keys (font.tables.post.glyphIDToName || []).forEach (glyphID => {
    var name = font.tables.post.glyphIDToName[glyphID];
    if (name == null) return;

    font.glyphNameToID[name] = glyphID;
  });

  var base = font.tables.base;
  if (base) ['horizAxis', 'vertAxis'].forEach (key => {
    base[key].DFLT = {};

    var sr = base[key].baseScriptRecords.filter (_ => _.baseScriptTag === 'DFLT')[0];
    if (!sr) return;
    var coords = ((sr.baseScript || {}).baseValues || {}).baseCoords || [];
    var tags = base[key].baselineTags;
    for (var i = 0; i < tags.length; i++) {
      base[key].DFLT[tags[i]] = (coords[i] || {}).coordinate;
    }
  });
  
  font.ideoEmboxLeft = 0;
  if (base && base.horizAxis.DFLT.ideo !== undefined) {
    font.ideoEmboxBottom = base.horizAxis.DFLT.ideo;
    if (base.horizAxis.DFLT.idtp !== undefined) {
      font.ideoEmboxTop = base.horizAxis.DFLT.idtp;
    } else {
      font.ideoEmboxTop = base.horizAxis.DFLT.ideo + font.tables.head.unitsPerEm;
    }
    if (base.vertAxis.DFLT.idtp !== undefined) {
      font.ideoEmboxRight = base.vertAxis.DFLT.idtp;
    } else {
      font.ideoEmboxRight = font.tables.head.unitsPerEm;
    }
    if (base.vertAxis.DFLT.ideo) {
      // Bad value
    }
  } else { // else if font is a CJK font
    font.ideoEmboxBottom = font.tables.os2.sTypoDescender;
    font.ideoEmboxTop = font.tables.os2.sTypoAscender;
    font.ideoEmboxRight = font.tables.head.unitsPerEm;
  } // else cannot be determined
  font.ideoEmboxCenterVertical = Math.trunc ((font.ideoEmboxRight + font.ideoEmboxLeft) / 2);
  font.ideoEmboxCenterHorizontal = Math.trunc ((font.ideoEmboxTop + font.ideoEmboxBottom) / 2);

  if (base && base.horizAxis.DFLT.icfb !== undefined) {
    base.icfBottom = base.horizAxis.DFLT.icfb;
    var margin = base.horizAxis.DFLT.icfb - font.ideoEmboxBottom;
    if (base.horizAxis.DFLT.icft !== undefined) {
      base.icfTop = base.horizAxis.DFLT.icft;
    } else {
      base.icfTop = font.ideoEmboxTop - margin;
    }
    if (base.vertAxis.DFLT.icfb !== undefined) {
      base.icfLeft = base.vertAxis.DFLT.icfb;
    } else {
      base.icfLeft = margin;
    }
    if (base.vertAxis.DFLT.icft !== undefined) {
      base.icfRight = base.vertAxis.DFLT.icft;
    } else {
      base.icfRight = font.ideoEmboxRight - base.icfLeft;
    }
    base.icfCenterVertical = Math.trunc ((base.icfRight + base.icfLeft) / 2);
    base.icfCenterHorizontal = Math.trunc ((base.icfTop + base.icfBottom) / 2);
  } else {
    // cannot be determined
  }

      var features = (font.tables.gsub || {features: []}).features.concat
          ((font.tables.gpos || {features: []}).features);
      var featureTags = {};
      for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        feature.index = i;
        featureTags[feature.tag] = true;
      }
      font.featureTagList = Object.keys (featureTags);

      var lookups = (font.tables.gsub || {lookups: []}).lookups.concat
          ((font.tables.gpos || {lookups: []}).lookups);
      for (var i = 0; i < lookups.length; i++) {
        var lookup = lookups[i];
        lookup.index = i;
        bitFields (lookup, 'lookupFlag', 16);
        lookup['lookupFlag-MARK_ATTACHMENT_TYPE'] = lookup.lookupFlag >> 8;
      }
      
        return font;
      }, // _initFont

      _showFont: function (parent, font, id) {
        console.log (font); // for devs
      
        var t = document.querySelector ('#font-template');
        var e = document.createElement ('section');
        e.className = 'font';
        e.id = id;
        e.setAttribute ('data-pjax-selecting', '#' + id + '-');
        e.appendChild (t.content.cloneNode (true));
        e.idPrefix = id;
        e.font = font;
        e.addEventListener ('otvShowGlyph', ev => {
          e.querySelector ('glyph-data').show (ev.glyphID, {
            values: ev.values,
            scroll: true,
          });
        });
        $fill (e, {id, name: font.names.fullName.en,
                   tableList: font.tableTags.map (_ => {
                     return {tag: _};
                   }),
                   gsubFeatureList: uniq (((font.tables.gsub || {}).features || []).map (_ => _.tag)).map (_ => {
                     return {tag: _};
                   }),
                   gposFeatureList: uniq (((font.tables.gpos || {}).features || []).map (_ => _.tag)).map (_ => {
                     return {tag: _};
                   }),
                   gsubLookupSummary: uniq (((font.tables.gsub || {}).lookups || []).map (l => l.subtables.map (s => [l.lookupType, s.substFormat, s.lookupType, (s.extension || {}).substFormat])).flat ()).sort ((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2] || a[3] - b[3]).map (_ => {
                     return '[N['+_[0]+']], [N['+_[1]+']]'+(_[2]?' ([N['+_[2]+']], [N['+_[3]+']])':'');
                   }).join ('; '),
                   gposLookupSummary: uniq (((font.tables.gpos || {}).lookups || []).map (l => l.subtables.map (s => [l.lookupType, s.posFormat, s.extensionLookupType, (s.extension || {}).posFormat])).flat ()).sort ((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2] || a[3] - b[3]).map (_ => {
                     return '[N['+_[0]+']], [N['+_[1]+']]'+(_[2]?' ([N['+_[2]+']], [N['+_[3]+']])':'');
                   }).join ('; ')});
        parent.appendChild (e);

        {
          var s = e.querySelector ('section.glyphs');
        
          s.querySelectorAll ('glyph-viewer').forEach (_ => {
            _.cmap = null;
          });

          s.querySelectorAll ('list-viewer').forEach (_ => {
            _.type = 'glyphs';
          });
        }

      var m = e.querySelector ('.table-menu');
      var mt = m.querySelector ('template');
      font.tableTags.forEach (t => {
        var li = document.createElement ('li')
        li.appendChild (mt.content.cloneNode (true));
        $fill (li, {id: id + '-' + t, tag: t});
        m.appendChild (li);
      });

      var container = e.querySelector ('.table-list');

      dumpTable (container, font, id, 'name', 'name');
      dumpTable (container, font, id, 'meta', 'meta');
      dumpTable (container, font, id, 'head', 'head');
      dumpTable (container, font, id, 'OS/2', 'os2');
      dumpTable (container, font, id, 'maxp', 'maxp');
      dumpTable (container, font, id, 'post', 'post');
      dumpTable (container, font, id, 'BASE', 'base');
      dumpTable (container, font, id, 'hhea', 'hhea');
      dumpTable (container, font, id, 'hmtx', 'hmtx');
      dumpTable (container, font, id, 'vhea', 'vhea');
      dumpTable (container, font, id, 'vmtx', 'vmtx');
      dumpTable (container, font, id, 'cmap', 'cmap');
      dumpTable (container, font, id, 'GDEF', 'gdef');
      dumpTable (container, font, id, 'GSUB', 'gsub');
      dumpTable (container, font, id, 'GPOS', 'gpos');
      //XXX VORG
      //XXX CFF
      //XXX FFTM
      //XXX cvt
      //XXX fpgm
      //XXX gasp
      //XXX prep
      //XXX prop
      //XXX DSIG
      //XXX feat
        //XXX morx
        //XXX MATH
        //XXX JSTF
      dumpTable (container, font, id, 'loca', 'loca');
        dumpTable (container, font, id, 'glyf', 'glyf');
      }, // _showFont

      },
    }); // <font-viewer>

    defineElement ({
      name: 'form',
      is: 'upload-form',
      props: {
        pcInit: function () {
          this.method = 'POST';
          this.action = 'javascript:';
          if (this.elements.file) this.elements.file.onchange = () => {
            var files = Array.prototype.slice.call (this.elements.file.files);
            this.elements.file.value = '';
            var fv = document.querySelector ('font-viewer');
            files.forEach (_ => fv.loadByBlob (_));
          };
          this.onsubmit = () => {
            var url = this.elements.url.value;
            var fv = document.querySelector ('font-viewer');
            fv.loadByURL (url, {});
          };
        },
      },
    }); // <form is=upload-form>

    defineElement ({
      name: 'item-list',
      fill: 'idlattribute',
      props: {
        pcInit: function () {
          var v = this.value || [];
          Object.defineProperty (this, 'value', {
            get: () => v,
            set: (newValue) => { v = newValue || []; this.update () },
          });
          
          var define = () => {
            var p = this.parentNode;
            while (p && !p.font) p = p.parentNode;
            if (p) {
              var font = p.font;
              var idPrefix = p.idPrefix;
              Object.defineProperty (this, 'font', {
                get: () => font,
              });
              Object.defineProperty (this, 'idPrefix', {
                get: () => idPrefix,
              });
            }
          };
          Object.defineProperty (this, 'font', {
            get: () => {
              define ();
              return this.font;
            },
            configurable: true,
          });
          Object.defineProperty (this, 'idPrefix', {
            get: () => {
              define ();
              return this.idPrefix;
            },
            configurable: true,
          });
          
          this.update ();
        },
        update: function () {
          var t = document.getElementById (this.getAttribute ('template'));
          this.textContent = '';
          var index = 0;
          this.value.forEach (item => {
            var li = document.createElement ('list-item');
            li.appendChild (t.content.cloneNode (true));
            $fill (li, {
              list: this,
              item,
              index,
            });
            this.appendChild (li);
            index++;
          });
        }, // update
      },
    }); // <item-list>

defineElement ({
  name: 'char-code',
  fill: 'idlattribute',
  props: {
    pcInit: function () {
      var v = parseInt (this.value || 0);
      Object.defineProperty (this, 'value', {
        get: () => v,
        set: (newValue) => { v = parseInt (newValue); this.update () },
      });
      this.update ();
    }, // pcInit
    update: function () {
      var value = this.value;

      if (value === 0 && this.hasAttribute ('nonzero')) {
        this.textContent = '-';
        return;
      }

      this.textContent = '';
      var isUnicode = this.hasAttribute ('isunicode');
      if (isUnicode) {
        var c = document.createElement ('code');
        c.className = 'unicode';
        var v = value.toString (16).toUpperCase ();
        if (v.length < 4) v = ("000" + v).substr (-4);
        c.textContent = 'U+' + v;
        this.appendChild (c);
        this.appendChild (document.createTextNode (' ('));

        var c = document.createElement ('data');
        c.className = 'char';
        c.textContent = String.fromCodePoint (value);
        this.appendChild (c);
        this.appendChild (document.createTextNode (') '));
      } else {
        var c = document.createElement ('data');
        c.className = 'dec';
        c.textContent = value;
        this.appendChild (c);
        this.appendChild (document.createTextNode (' '));

        var c = document.createElement ('data');
        c.className = 'hex';
        c.textContent = '0x' + value.toString (16).toUpperCase ();
        this.appendChild (c);
        this.appendChild (document.createTextNode (' '));
      }

      if (this.hasAttribute ('viewerselector')) {
        var b = document.createElement ('button');
        b.type = 'button';
        b.textContent = 'Show';
        b.onclick = () => document.querySelector (this.getAttribute ('viewerselector')).show ({code: value, isUnicode, scroll: true});
        this.appendChild (b);
      }
    }, // update
  }, // props
}); // <char-code>

    defineElement ({
      name: 'glyph-image',
      fill: 'idlattribute',
      props: {
        pcInit: function () {
          this._init ();

          var v = this.value;
          Object.defineProperty (this, 'value', {
            get: () => v,
            set: (newValue) => { v = newValue; this.update () },
          });
          this.update ();
        },
        _init: function () {
          var svg = document.createElementNS
              ('http://www.w3.org/2000/svg', 'svg');
          svg.hidden = true;
          this.appendChild (svg);

          var p = this.parentNode;
          while (p && !p.font) p = p.parentNode;
          if (p) {
            this.font = p.font;
            this.idPrefix = p.idPrefix;
          }
        }, // _init
        update: function () {
          var svg = this.firstChild;
          var glyphID = this.value;
          var posValues = null;
          if (Array.isArray (glyphID)) {
            posValues = glyphID[1];
            glyphID = glyphID[0];
          }
          glyphID = parseInt (glyphID);
          if (!Number.isFinite (glyphID) || glyphID < 0) return svg.hidden = true;
          svg.hidden = false;

          Promise.resolve ().then (() => {
            var glyph = OT.getGlyph (this.font, glyphID);
            this._drawGlyph (svg, glyph, posValues, {});
          });
        }, // update

        _drawGlyph: function (svg, glyph, posValues, opts) {
          var font = this.font;

          var detailLines = this.hasAttribute ('details');
          
          var fontSize = opts.fontSize || 160;
          var size = this.getAttribute ('size') || '';
          var sized = false;
          if (size === 'lowestRec') {
            fontSize = font.tables.head.lowestRecPPEM;
            sized = true;
          } else if (size.match (/^[0-9]+(?:\.[0-9]+|)$/)) {
            fontSize = parseFloat (size);
            sized = true;
          }

  var upem = font.tables.head.unitsPerEm || 1000;
  var tf = [x => x, y => y];
          var tfed = false;
          var tfadv = false;
  var scale = [1, 1];
  var scaleSub = [font.tables.os2.ySubscriptXSize / upem,
                  font.tables.os2.ySubscriptYSize / upem];
  var tfSub = [x => x * scaleSub[0] + font.tables.os2.ySubscriptXOffset,
               y => y * scaleSub[1] - font.tables.os2.ySubscriptYOffset];
  var scaleSup = [font.tables.os2.ySuperscriptXSize / upem,
                  font.tables.os2.ySuperscriptYSize / upem];
  var tfSup = [x => x * scaleSup[0] + font.tables.os2.ySuperscriptXOffset,
               y => y * scaleSup[1] + font.tables.os2.ySuperscriptYOffset];
          // x : offset from origin
          // y : offset from baseline
          var variant = this.getAttribute ('variant');
          if (variant === 'subscript') {
            scale = scaleSub;
            tf = tfSub;
            tfed = true;
            tfadv = true;
          } else if (variant === 'superscript') {
            scale = scaleSup;
            tf = tfSup;
            tfed = true;
            tfadv = true;
          } else {
            if (posValues &&
                (posValues.xPlacement != null ||
                 posValues.yPlacement != null)) {
              var xP = posValues.xPlacement || 0;
              var yP = posValues.yPlacement || 0;
              var tfPlace = [x => x + xP, y => y + yP];
              tf = tfPlace;
              tfed = true;
            }
          }
  
  var margin = opts.margin || 16;
  var xMin = font.tables.head.xMin;
  var yMin = font.tables.head.yMin;
  var xMax = font.tables.head.xMax;
  var yMax = font.tables.head.yMax;
  var origin = [0, upem];
  var min = [xMin - margin, yMin - margin];
  var max = [xMax + margin, yMax + margin];
  var extend = (x, y) => {
    if (x < min[0]) min[0] = x;
    if (max[0] < x) max[0] = x;
    if (y < min[1]) min[1] = y;
    if (max[1] < y) max[1] = y;
  };
  extend (0 - margin, 0 - margin);
  extend (tfSub[0] (0) - margin, tfSub[1] (0) - margin);
  extend (tfSup[0] (0) - margin, tfSup[1] (0) - margin);
  extend (xMin - margin, yMin - margin);
  extend (tfSub[0] (xMin) - margin, tfSub[1] (yMin) - margin);
  extend (tfSup[0] (xMin) - margin, tfSup[1] (yMin) - margin);
  extend (xMax + margin, yMax + margin);
  extend (tfSub[0] (xMax) + margin, tfSub[1] (yMax) + margin);
  extend (tfSup[0] (xMax) + margin, tfSup[1] (yMax) + margin);
  extend (0, font.tables.os2.sTypoAscender);
  extend (0, font.tables.os2.sTypoDescender);
  extend (0, font.tables.os2.usWinAscent);
  extend (0, font.tables.os2.usWinDescent);
  extend (0, tfSub[1] (font.tables.os2.sTypoAscender));
  extend (0, tfSub[1] (font.tables.os2.sTypoDescender));
  extend (0, tfSub[1] (font.tables.os2.usWinAscent));
  extend (0, tfSub[1] (font.tables.os2.usWinDescent));
  extend (0, tfSup[1] (font.tables.os2.sTypoAscender));
  extend (0, tfSup[1] (font.tables.os2.sTypoDescender));
  extend (0, tfSup[1] (font.tables.os2.usWinAscent));
  extend (0, tfSup[1] (font.tables.os2.usWinDescent));
  var width = max[0] - min[0] + 1;
  var height = max[1] - min[1] + 1;
  svg.setAttribute ('viewBox', [
    min[0], origin[1] - max[1],
    width, height,
  ].join (' '));
          glyph.getBoundingBox (); // parse glyf data such as glyph._yMax
          var vOrigin = [font.ideoEmboxCenterVertical,
                         glyph.topSideBearing + glyph.metrics.yMax];

  svg.style.width = width * fontSize / upem + 'px';
  svg.style.height = height * fontSize / upem + 'px';
  svg.style.setProperty ('--px', upem / fontSize);

          svg.textContent = '';
          var lines = document.createElementNS (svg.namespaceURI, 'g');
          lines.setAttribute ('class', 'lines');
          svg.appendChild (lines);
          var points = document.createElementNS (svg.namespaceURI, 'g');
          points.setAttribute ('class', 'points');
          svg.appendChild (points);

  var path = glyph.getPath (origin[0] + tf[0] (0),
                            origin[1] - tf[1] (0), upem, {
                              xScale: scale[0], yScale: scale[1],
                            });
        svg.appendChild (path.toDOMElement ());
        if (!sized) {
        //  glyph.drawPoints (ctx, origin[0], origin[1], fontSize);
        }

  var addXLine = (x, cls, opts) => {
    if (!Number.isFinite (x)) return;
    var line = document.createElementNS (svg.namespaceURI, 'line');
    line.setAttribute ('class', cls);
    var xT = opts.transform ? tf[0] : x => x;
    var yT = opts.transform ? tf[1] : y => y;
    var xT0 = xT;
    var yT0 = yT;
    if (opts.vertical) {
      if (!Number.isFinite (vOrigin[1])) return;
      xT = x => xT0 (vOrigin[0] + x);
      yT = y => yT0 (vOrigin[1] - y);
    }
    line.setAttribute ('x1', origin[0] + xT (x));
    line.setAttribute ('x2', origin[0] + xT (x));
    line.setAttribute ('y1', origin[1] - yT0 (yMin - margin));
    line.setAttribute ('y2', origin[1] - yT0 (yMax + margin));
    lines.appendChild (line);
  };
  var addYLine = (y, cls, opts) => {
    if (!Number.isFinite (y)) return;
    var line = document.createElementNS (svg.namespaceURI, 'line');
    var xT = opts.transform ? tf[0] : x => x;
    var yT = opts.transform ? tf[1] : y => y;
    var xT0 = xT;
    var yT0 = yT;
    if (opts.vertical) {
      if (!Number.isFinite (vOrigin[1])) return;
      xT = x => xT0 (vOrigin[0] + x);
      yT = y => yT0 (vOrigin[1] - y);
    }
    line.setAttribute ('class', cls);
    line.setAttribute ('x1', origin[0] + xT0 (xMin - margin));
    line.setAttribute ('x2', origin[0] + xT0 (xMax + margin));
    line.setAttribute ('y1', origin[1] - yT (y));
    line.setAttribute ('y2', origin[1] - yT (y));
    if (opts.size) {
      line.style.setProperty ('--size', opts.size);
    }
    lines.appendChild (line);
  };
  var addLine = (x1, y1, x2, y2, cls, opts) => {
    var line = document.createElementNS (svg.namespaceURI, 'line');
    var xT = opts.transform ? tf[0] : x => x;
    var yT = opts.transform ? tf[1] : y => y;
    line.setAttribute ('class', cls);
    line.setAttribute ('x1', origin[0] + xT (x1));
    line.setAttribute ('x2', origin[0] + xT (x2));
    line.setAttribute ('y1', origin[1] - yT (y1));
    line.setAttribute ('y2', origin[1] - yT (y2));
    if (opts.size) {
      line.style.setProperty ('--size', opts.size);
    }
    lines.appendChild (line);
  };
          var addPoint = (x, y, cls, opts) => {
            var xT = opts.transform ? tf[0] : x => x;
            var yT = opts.transform ? tf[1] : y => y;
            var pt = document.createElementNS (svg.namespaceURI, 'circle');
            pt.setAttribute ('class', cls);
            pt.setAttribute ('cx', origin[0] + xT (x));
            pt.setAttribute ('cy', origin[1] - yT (y));
            points.appendChild (pt);
          }; // addPoint
  
  addXLine (0, 'axis', {});
  addYLine (0, 'axis', {});
  if (tfed) {
    addXLine (0, 'axis', {transform: true});
    addYLine (0, 'axis', {transform: true});
  }
  addXLine (0, 'vaxis', {vertical: true});
  addYLine (0, 'vaxis', {vertical: true});

  if (detailLines) {
    if (font.tables.post) {
      var angle = font.tables.post.italicAngle;
      angle += 90;
      angle *= Math.PI * 2 / 360;
      var r = font.tables.os2.sTypoAscender;
      addLine (0, 0, r * Math.cos (angle), r * Math.sin (angle),
               'italic', {});
    }
    if (font.tables.hhea) {
      var rise = font.tables.hhea.caretSlopeRise;
      var run = font.tables.hhea.caretSlopeRun;
      var r = font.tables.os2.sTypoAscender;
      var re = (rise * rise + run * run) || 1;
      var f = r / Math.pow (re, 0.5);
      var dx = glyph.advanceWidth;
      addLine (dx, 0, dx + run * f, rise * f, 'italic', {});
    }
    if (font.tables.vhea) {
      var rise = font.tables.vhea.caretSlopeRise;
      var run = font.tables.vhea.caretSlopeRun;
      var r = font.tables.os2.sTypoAscender;
      var re = (rise * rise + run * run) || 1;
      var f = r / Math.pow (re, 0.5);
      var dy = glyph.advanceHeight;
      var dx = (font.tables.base && font.tables.base.vertAxis && font.tables.base.vertAxis.DFLT) ? font.tables.base.vertAxis.DFLT.romn : 0;
      addLine (dx, vOrigin[1] - dy, dx + run * f, vOrigin[1] - (dy + rise * f), 'italic', {});
    }

    addXLine (xMin, 'bounding', {transform: false});
    addXLine (xMax, 'bounding', {transform: false});
    addYLine (yMin, 'bounding', {transform: false});
    addYLine (yMax, 'bounding', {transform: false});
    if (tfed) {
      addXLine (xMin, 'bounding', {transform: true});
      addXLine (xMax, 'bounding', {transform: true});
      addYLine (yMin, 'bounding', {transform: true});
      addYLine (yMax, 'bounding', {transform: true});
    }
    addXLine (font.ideoEmboxLeft, 'ideoEmbox', {});
    addXLine (font.ideoEmboxRight, 'ideoEmbox', {});
    addYLine (font.ideoEmboxTop, 'ideoEmbox', {});
    addYLine (font.ideoEmboxBottom, 'ideoEmbox', {});
    addXLine (font.ideoEmboxCenterVertical, 'ideoEmbox', {});
    addYLine (font.ideoEmboxCenterHorizontal, 'ideoEmbox', {});
    if (tfed) {
      addXLine (font.ideoEmboxLeft, 'ideoEmbox', {transform: true});
      addXLine (font.ideoEmboxRight, 'ideoEmbox', {transform: true});
      addYLine (font.ideoEmboxTop, 'ideoEmbox', {transform: true});
      addYLine (font.ideoEmboxBottom, 'ideoEmbox', {transform: true});
      addXLine (font.ideoEmboxCenterVertical, 'ideoEmbox', {transform: true});
      addYLine (font.ideoEmboxCenterHorizontal, 'ideoEmbox', {transform: true});
    }
    if (font.tables.base) {
      addXLine (font.tables.base.icfLeft, 'icf', {});
      addXLine (font.tables.base.icfRight, 'icf', {});
      addYLine (font.tables.base.icfTop, 'icf', {});
      addYLine (font.tables.base.icfBottom, 'icf', {});
      addXLine (font.tables.base.icfCenterVertical, 'icf', {});
      addYLine (font.tables.base.icfCenterHorizontal, 'icf', {});
      if (tfed) {
        addXLine (font.tables.base.icfLeft, 'icf', {transform: true});
        addXLine (font.tables.base.icfRight, 'icf', {transform: true});
        addYLine (font.tables.base.icfTop, 'icf', {transform: true});
        addYLine (font.tables.base.icfBottom, 'icf', {transform: true});
        addXLine (font.tables.base.icfCenterVertical, 'icf', {transform: true});
        addYLine (font.tables.base.icfCenterHorizontal, 'icf', {transform: true});
      }
    }
    addXLine (font.tables.os2.xAvgCharWidth, 'average', {transform: true});

    // baseline +
    addYLine (font.tables.os2.yStrikeoutPosition, 'strikeout', {
      size: font.tables.os2.yStrikeoutSize,
    });
    // baseline +
    addYLine (font.tables.post.underlinePosition, 'underline', {
      size: font.tables.post.underlineThickness,
    });

    addYLine (font.tables.os2.sTypoAscender, 'typo', {transform: true});
    addYLine (font.tables.os2.sTypoDescender, 'typo', {transform: true});
    addYLine (font.tables.os2.sTypoAscender + font.tables.os2.sTypoLineGap, 'typo', {});
    addYLine (font.tables.os2.usWinAscent, 'win', {transform: true});
    addYLine (-font.tables.os2.usWinDescent, 'win', {transform: true});

    addYLine (font.tables.os2.sxHeight, 'height', {transform: true});
    addYLine (font.tables.os2.sCapHeight, 'height', {transform: true});

    if (font.tables.hhea) {
      addYLine (font.tables.hhea.ascender, 'hheaheight', {transform: true});
      addYLine (font.tables.hhea.descender, 'hheaheight', {transform: true});
      addYLine (font.tables.hhea.ascender + font.tables.hhea.lineGap, 'hheaheight', {transform: true});
      addXLine (font.tables.hhea.advanceWidthMax, 'hheawidth', {transform: tfadv});
      addXLine (font.tables.hhea.minLeftSideBearing, 'hheawidth', {transform: true});
      addXLine (glyph.advanceWidth - font.tables.hhea.minRightSideBearing, 'hheawidth', {transform: tfadv});
      addXLine (font.tables.hhea.xMaxExtent, 'hheawidth', {transform: tfadv});
    }
    if (font.tables.vhea) {
      addXLine (font.tables.vhea.vertTypoAscender, 'vheawidth', {transform: true, vertical: true});
      addXLine (font.tables.vhea.vertTypoDescender, 'vheawidth', {transform: true, vertical: true});
      addXLine (font.tables.vhea.vertTypoAscender + font.tables.vhea.vertTypoLineGap, 'vheawidth', {transform: true, vertical: true});
      addYLine (font.tables.vhea.advanceHeightMax, 'vheaheight', {transform: true, vertical: true});
      addYLine (glyph.topSideBearing + font.tables.vhea.minTopSideBearing, 'vheaheight', {transform: tfadv, vertical: true});
      addYLine (glyph.advanceHeight - font.tables.vhea.minBottomSideBearing, 'vheaheight', {transform: tfadv, vertical: true});
      addYLine (font.tables.vhea.yMaxExtent, 'vheaheight', {transform: true, vertical: true});
    }

    if (font.tables.base && font.tables.base.horizAxis &&
        font.tables.base.horizAxis.DFLT) {
      addYLine (font.tables.base.horizAxis.DFLT.hang, 'baseline hang', {});
      addYLine (font.tables.base.horizAxis.DFLT.icfb, 'baseline icfb', {});
      addYLine (font.tables.base.horizAxis.DFLT.icft, 'baseline icft', {});
      addYLine (font.tables.base.horizAxis.DFLT.ideo, 'baseline ideo', {});
      addYLine (font.tables.base.horizAxis.DFLT.idtp, 'baseline idtp', {});
      addYLine (font.tables.base.horizAxis.DFLT.math, 'baseline math', {});
      addYLine (font.tables.base.horizAxis.DFLT.romn, 'baseline romn', {});
    }
    if (font.tables.base && font.tables.base.vertAxis &&
        font.tables.base.vertAxis.DFLT) {
      addXLine (font.tables.base.vertAxis.DFLT.hang, 'baseline hang', {});
      addXLine (font.tables.base.vertAxis.DFLT.icfb, 'baseline icfb', {});
      addXLine (font.tables.base.vertAxis.DFLT.icft, 'baseline icft', {});
      addXLine (font.tables.base.vertAxis.DFLT.ideo, 'baseline ideo', {});
      addXLine (font.tables.base.vertAxis.DFLT.idtp, 'baseline idtp', {});
      addXLine (font.tables.base.vertAxis.DFLT.math, 'baseline math', {});
      addXLine (font.tables.base.vertAxis.DFLT.romn, 'baseline romn', {});
    }
  }

          addXLine (0, 'advance', {transform: tfadv});
          addXLine (glyph.advanceWidth, 'advance', {transform: tfadv});
          addYLine (vOrigin[1], 'advance', {transform: tfadv});
          addYLine (vOrigin[1] - glyph.advanceHeight, 'advance',
                    {transform: tfadv});
          if (posValues) {
            var aw = glyph.advanceWidth;
            if (posValues.xAdvance != null) aw += posValues.xAdvance;
            var ah = glyph.advanceHeight;
            if (posValues.yAdvance != null) ah += posValues.yAdvance;
            addXLine (aw, 'advance modified', {transform: tfadv});
            addYLine (vOrigin[1] - ah, 'advance modified', {transform: tfadv});
          }
          
          if (detailLines) {
            addXLine (glyph.leftSideBearing, 'sideBearing', {transform: true});
            addXLine (glyph.advanceWidth - glyph.metrics.rightSideBearing,
                      'sideBearing', {transform: tfadv});
            addYLine (vOrigin[1] - glyph.topSideBearing, 'sideBearing',
                      {transform: true});
            addXLine (glyph._xMin, 'glyph', {transform: true});
            addXLine (glyph._xMax, 'glyph', {transform: true});
            addYLine (glyph._yMin, 'glyph', {transform: true});
            addYLine (glyph._yMax, 'glyph', {transform: true});
    //XXX if CFF,...

            if (posValues) {
              if (posValues.anchor) {
                addPoint (posValues.anchor.xCoordinate,
                          posValues.anchor.yCoordinate,
                          'mark anchor', {transform: true});
              }
              if (posValues.entryAnchor) {
                addPoint (posValues.entryAnchor.xCoordinate,
                          posValues.entryAnchor.yCoordinate,
                          'entry anchor', {transform: true});
              }
              if (posValues.exitAnchor) {
                addPoint (posValues.exitAnchor.xCoordinate,
                          posValues.exitAnchor.yCoordinate,
                          'exit anchor', {transform: true});
              }
            } // posValues
          } // detailLines
        }, // _drawGlyph

      },
    }); // <glyph-image>

defineElement ({
  name: 'glyph-viewer',
  props: {
    pcInit: function () {
      this.inputs = [];
      this.isUnicode = false;
      this.isDefault = false;
      this.isBreak = false;
      //this.font
      //this.idPrefix
      this.lookups = this.lookups || [];
      this.selectedFeatures = {};
      this.initInput ();
      this.update ();
    }, // pcInit
    initInput: function () {
      var t = document.querySelector ('#glyph-viewer-template');
      this.appendChild (t.content.cloneNode (true));

      this.querySelectorAll ('form[is=glyph-viewer-input]').forEach (f => {
        f.action = 'javascript:';
        f.elements.inputText.oninput = (ev) => {
          this.inputs = ev.target.value.split (/(?:)/u).map (_ => {
            return {
              type: 'char',
              charCode: _.codePointAt (0),
              isUnicode: true,
            };
          });
          this.search ();
        };
        f.elements.inputHex.oninput = (ev) => {
          this.inputs = ev.target.value.split (/\s+/).map (_ => {
            var m = _.match (/^[Uu]\+([0-9A-Fa-f]+)$/);
            if (m) {
              return {
                type: 'char',
                charCode: parseInt (m[1], 16),
                isUnicode: true,
              };
            }

            var m = _.match (/^"([^"]+)"$/);
            if (m) return m[1].split (/(?:)/u).map (_ => {
              return {
                type: 'char',
                charCode: _.codePointAt (0),
                isUnicode: true,
              };
            });

            if (_ === '') return null;

            var n = parseInt (_);
            if (Number.isFinite (n)) return {
              type: 'char',
              charCode: n,
              _checkIsUnicode: true,
            };

            return {
              type: 'default',
              isFallback: true,
            };
          }).filter (_ => _).flat ();
          this.search (); 
        };
        f.elements.inputGlyphID.oninput = (ev) => {
          this.inputs = ev.target.value.split (/\s+/).filter (_ => _.length).map (_ => {
            if (_.match (/^[0-9]+$/)) {
              return {
                type: 'glyph',
                glyphID: parseInt (_),
              };
            }

            if (_ === '') return null;

            return {
              type: 'glyph-name',
              glyphName: _,
            };
          }).filter (_ => _);
          this.search ();
        };
        f.elements.inputIsUnicode.oninput = ev => {
          this.isUnicode = ev.target.checked;
          this.search ();
        };
        f.elements.inputIsDefault.oninput = ev => {
          this.isDefault = ev.target.checked;
          this.search ();
        };
        f.elements.inputIsBreak.oninput = ev => {
          this.isBreak = ev.target.checked;
          this.search ();
        };
      });

          var p = this.parentNode;
          while (p && !p.font) p = p.parentNode;
          if (p) {
            this.font = p.font;
            this.idPrefix = p.idPrefix;
          }
    }, // initInput
    update: async function () {
      clearTimeout (this._updateTimer);
      this._updateTimer = setTimeout (() => this._update (), 500);
    }, // update
    _update: function () {
      this.querySelectorAll ('[data-glyph-viewer-type=input-glyph]').forEach (_ => _.hidden = !! this.cmap);
      var featureDefaults = {
        abvf: true, // auto
        abvm: true, // auto
        abvs: true, // auto
        akhn: true, // auto
        blwf: true, // auto
        blwm: true, // auto
        blws: true, // auto
        calt: true,
        ccmp: true,
        clig: true,
        curs: true,
        liga: true,
        mark: true,
        mkmk: true,
        pref: true, // auto
        pres: true, // auto
        pstf: true, // auto
        psts: true, // auto
        nukt: true, // auto
        rphf: true, // auto
        rlig: true, // auto
        vatu: true, // auto

        //init medi fina isol // auto
        //rtla rtlm // auto
        //dnom numr // auto
        //dtls // auto

        chws: true, // if horizontal CJK & ! advanced
        kern: true, // if horizontal
        loca: true, // language-specific
        vert: false, // true if vertical
        vrt2: false, // true if vertical
        vkrn: false, // true if vertical
        //expt pwid can be true or false
        //ital if italic
      };
      this.querySelectorAll ('.feature-list').forEach (_ => {
        _.hidden = this.lookups;
        if (_.hidden) return;

        this.font.featureTagList.forEach (tag => {
          var label = document.createElement ('label');
          var input = document.createElement ('input');
          input.type = 'checkbox';
          input.oninput = ev => {
            this.selectedFeatures[tag] = ev.target.checked;
            this._resetLookup ();
            this.search ();
          };
          this.selectedFeatures[tag] = input.checked = !!featureDefaults[tag];
          label.appendChild (input);
          label.appendChild (document.createTextNode (' '));
          var code = document.createElement ('code');
          code.className = 'tag';
          code.textContent = tag;
          label.appendChild (code);
          _.appendChild (label);
        });
        this._resetLookup ();
      });
    }, // update
    _resetLookup: function () {
      var lookups = [];
      Object.keys (this.selectedFeatures).forEach (tag => {
        if (!this.selectedFeatures[tag]) return;
        
        var feature = ((this.font.tables.gsub || {}).features || []).filter (_ => _.tag === tag)[0];
        if (feature) feature.feature.lookupListIndexes.forEach (index => {
          var lookup = this.font.tables.gsub.lookups[index];
          lookups.push ({
            lookup,
            feature,
            table: 0 /* GSUB */,
          });
        });
        
        var feature = ((this.font.tables.gpos || {}).features || []).filter (_ => _.tag === tag)[0];
        if (feature) feature.feature.lookupListIndexes.forEach (index => {
          var lookup = this.font.tables.gpos.lookups[index];
          lookups.push ({
            lookup,
            feature,
            table: 1 /* GPOS */,
          });
        });
      });
      this.lookups = lookups.sort ((a, b) => a.table - b.table || a.index - b.index);
    }, // _resetLookup
    show: function (opts) {
      if (opts.code != null) {
        this.querySelectorAll ('input[name=inputHex]').forEach (_ => {
          _.value = '0x' + opts.code.toString (16).toUpperCase ();
          _.dispatchEvent (new Event ('input', {bubbles: true}));
        });
      }

      if (opts.isUnicode !== undefined) {
        this.querySelectorAll ('input[name=inputIsUnicode]').forEach (_ => {
          _.checked = opts.isUnicode;
          _.dispatchEvent (new Event ('input', {bubbles: true}));
        });
      }

      if (opts.scroll) this.scrollIntoView ();
    }, // show
    search: function () {
      clearTimeout (this.timer);
      this.timer = setTimeout (() => this._search (), 200);
    }, // search
    _search: function () {
      var container = this.querySelector ('glyph-viewer-result-items');
      container.textContent = '';

      var font = this.font;
      var cmaps = this.cmap ? [this.cmap] : font.tables.cmap.subtables;

      var nextInputs = [];
      if (this.isDefault) {
        nextInputs.push ([{type: 'default'}]);
      } else if (this.isBreak) {
        nextInputs.push ([{type: 'break'}]);
      } else if (this.inputs.length) {
        nextInputs.push (this.inputs.map (_ => {
          if (_._checkIsUnicode) {
            var v = {};
            for (var n in _) {
              v[n] = _[n];
            }
            _.isUnicode = this.isUnicode;
            return v;
          } else {
            return _;
          }
        }));
      } else {
        //
      }
      nextInputs.forEach (seq => seq.forEach (item => item.stepses = [[item]]));

      var seqs = nextInputs;
      var iteration = (itemHandlers) => {
        var inxSeq = [];
        var outSeqs = [];
        var outSteps = [];
        var changed = false;
        seqs.forEach (inSeq => {
          var newSeqs = [];
          newSeqs.push ([]);
          for (var i = 0 ; i < inSeq.length; i++) {
            var inSeqItem = inxSeq[i] || inSeq[i];
            var handler = itemHandlers[inSeqItem.type];
            var j = i;
            var k = i;
            var l = null;
            var r = handler ? handler (inSeqItem, {
              getNextItem: () => inSeq[++j], // or undefined
              getPrevItem: () => inSeq[--k], // or undefined
              setSkipPoint: () => l = j,
              resetLookahead: () => { j = k = i; l = null },
            }) : null;
            if (!r) {
              newSeqs.forEach (outSeq => {
                if (outSeq.skip > 0) {
                  outSeq.skip--;
                } else {
                  outSeq.push (inSeqItem);
                }
              });
            } else if (r.operation === 'replace') {
              newSeqs.forEach (outSeq => {
                if (outSeq.skip > 0) {
                  outSeq.skip--;
                } else {
                  var added = [{item: r.by,
                                operators: r.byOperators}].concat (r.append || []);
                  added.forEach (_ => outSeq.push (_.item));
                  added[0].item.stepses = inSeqItem.stepses.map (_ => _.slice ());
                  var operators = [];
                  if (r.operator) operators.push (r.operator);
                  (r.additionalOperators || []).forEach (_ => operators.push (_));
                  added[0].item.stepses.forEach (steps => {
                    operators.forEach (_ => steps.push (_));
                    (added[0].operators || []).forEach (_ => steps.push (_));
                    steps.push (added[0].item);
                  });
                  var ai = 0;
                  if (r.skipNextItems) {
                    outSeq.skip = 0;
                    if (l === null) l = j;
                    for (var k = i + 1; k <= l; k++) {
                      outSeq.skip++;
                      var aa = added[++ai] || added[added.length - 1];
                      aa.item.stepses = aa.item.stepses || [];
                      inSeq[k].stepses.forEach (steps => {
                        var ss = steps.slice ();
                        operators.forEach (_ => ss.push (_));
                        (aa.operators || []).forEach (_ =>  ss.push (_));
                        ss.push (aa.item);
                        aa.item.stepses.push (ss);
                      });
                    }
                  } // skipNextItems
                  var aa0 = added[ai];
                  for (var k = ai; k < added.length; k++) {
                    var aa = added[k];
                    aa.item.stepses = [aa0.item.stepses[aa0.item.stepses.length-1].slice ()];
                    aa.item.stepses[0][aa.item.stepses[0].length-1] = aa.item;
                  }
                }
              });
              changed = true;
            } else if (r.operation === 'modify') {
              newSeqs.forEach (outSeq => {
                if (outSeq.skip > 0) {
                  outSeq.skip--;
                } else {
                  var added = [{item: r.by,
                                operators: r.byOperators}];
                  var outSeqItem = {};
                  for (var n in inSeqItem) outSeqItem[n] = inSeqItem[n];
                  outSeqItem.values = (inSeqItem.values || []).slice ();
                  outSeqItem.values.unshift (added[0].item);
                  outSeq.push (outSeqItem);
                  outSeqItem.stepses = inSeqItem.stepses.map (_ => _.slice ());
                  var operators = [];
                  if (r.operator) operators.push (r.operator);
                  (r.additionalOperators || []).forEach (_ => operators.push (_));
                  outSeqItem.stepses.forEach (steps => {
                    operators.forEach (_ => steps.push (_));
                    (added[0].operators || []).forEach (_ => steps.push (_));
                    steps.push (outSeqItem);
                  });
                  var j = i;
                  (r.nexts || []).forEach (nx => {
                    j++;
                    var outSeqItem = {};
                    var inSeqItem = inxSeq[j] || inSeq[j];
                    for (var n in inSeqItem) outSeqItem[n] = inSeqItem[n];
                    outSeqItem.values = (inSeqItem.values || []).slice ();
                    outSeqItem.values.unshift (nx.item);
                    inxSeq[j] = outSeqItem;
                    outSeqItem.stepses = inSeqItem.stepses.map (_ => _.slice ());
                    outSeqItem.stepses.forEach (steps => {
                      operators.forEach (_ => steps.push (_));
                      (nx.operators || []).forEach (_ => steps.push (_));
                      steps.push (outSeqItem);
                    });
                  });
                  if (r.prevBy) {
                    var outSeqItem = {};
                    var oinSeqItem = outSeq[k];
                    for (var n in inSeqItem) outSeqItem[n] = oinSeqItem[n];
                    outSeqItem.values = (inSeqItem.values || []).slice ();
                    outSeqItem.values.unshift (r.prevBy);
                    outSeq[k] = outSeqItem;
                    outSeqItem.stepses = oinSeqItem.stepses.map (_ => _.slice ());
                    outSeqItem.stepses.forEach (steps => {
                      operators.forEach (_ => steps.push (_));
                      //(nx.operators || []).forEach (_ => steps.push (_));
                      steps.push (outSeqItem);
                    });
                  } // r.prevBy
                }
              });
              changed = true;
            } else if (r.operation === 'fork') {
              var newNewSeqs = [];
              newSeqs.forEach (outSeq => {
                if (outSeq.skip > 0) {
                  outSeq.skip--;
                } else {
                  r.lines.forEach (({item, operator}) => {
                    item.stepses = inSeqItem.stepses.map (_ => _.slice ());
                    item.stepses.forEach (steps => {
                      if (operator) steps.push (operator);
                      steps.push (item);
                    });
                    var newOutSeq = outSeq.concat ([item]);
                    if (r.skipNextItems) {
                      newOutSeq.skip = 0;
                      if (l === null) l = j;
                      for (var k = i + 1; k <= l; k++) {
                        newOutSeq.skip++;
                        inSeq[k].stepses.forEach (steps => {
                          item.stepses.push (steps.concat ([item]));
                        });
                      }
                    }
                    newNewSeqs.push (newOutSeq);
                  });
                  if (r.keepCurrent) {
                    var item = {};
                    for (var n in inSeqItem) item[n] = inSeqItem[n];
                    item.stepses = inSeqItem.stepses.map (_ => _.slice ());
                    item.stepses.forEach (steps => {
                      if (r.currentOperator) {
                        steps.push (r.currentOperator);
                        steps.push (item);
                      }
                    });
                    newNewSeqs.push (outSeq.concat ([item]));
                    // r.skipNextItems not checked
                  } // keepCurrent
                }
              });
              newSeqs = newNewSeqs;
              changed = true;
            } else {
              throw r;
            }
          } // inSeqItem
          outSeqs = outSeqs.concat (newSeqs);
        });

        seqs = outSeqs;
        return changed;
      }; // iteration

      iteration ({
        'glyph-name': (item, ops) => {
          var glyphID = font.glyphNameToID[item.glyphName];
          if (glyphID != null) {
            return {
              operation: 'replace',
              by: {
                type: 'glyph',
                glyphID,
              },
            };
          } else {
            return {
              operation: 'replace',
              by: {
                type: 'default',
                isFallback: true,
              },
            };
          }
        },
      }, {
        name: 'Resolve glyph names',
      });

      iteration ({
        char: (item, ops) => {
          item.isUnicodeAttr = item.isUnicode ? '' : undefined;
          var nextItem = ops.getNextItem (); // or undefined
          var vsCode = nextItem && nextItem.type === 'char' && nextItem.charCode;
          if ((0x180B <= vsCode && vsCode <= 0x180D) ||
              vsCode === 0x180F ||
              (0xFE00 <= vsCode && vsCode <= 0xFE0F) ||
              (0xE0100 <= vsCode && vsCode <= 0xE01EF)) {
            return {
              operation: 'fork',
              keepCurrent: true,
              skipNextItems: true,
              lines: [
                {
                  item: {type: 'vs', charCode: item.charCode, vsCode},
                },
              ],
            };
          }
          return null; // unchanged
        }, // vs
      }, {
        name: 'Grouping variation sequences',
      });

      while (true) {
        var changed = false;

        changed = changed || iteration ({
          char: (item, ops) => {
            item.isUnicodeAttr = item.isUnicode ? '' : undefined;
          var glyphs = [];
          cmaps.forEach (cmap => {
            // XXX item.isUnicode cmap.isUnicode
            var m = (cmap.glyphIndexMap || [])[item.charCode];
              if (m != null) {
                glyphs[m] = glyphs[m] || {
                  item: {
                    type: 'glyph', glyphID: m,
                    isDefault: item.isDefault,
                    isFallback: item.isFallback,
                    isVSFallback: item.isVSFallback,
                  },
                  operator: {type: 'cmaps', cmaps: []},
                };
                glyphs[m].operator.cmaps.push (cmap);
              } // else, not found
            }); // cmap
          
            if (glyphs.length) {
              return {
                operation: 'fork',
                lines: glyphs,
              };
            } else {
              if (item.isDefault) { // usDefaultChar is broken
                return {
                  operation: 'replace',
                  operator: {type: 'cmap-no-match'},
                  by: {type: 'glyph', glyphID: 0,
                       isDefault: true, isFallback: true},
                };
              } else {   
                return {
                  operation: 'replace',
                  by: {type: 'default', isFallback: true},
                  operator: {type: 'cmap-no-match'},
                };
              }
            }
          }, // char
          vs: (item, ops) => {
          var chars = [];
          var glyphs = [];
          cmaps.forEach (cmap => {
            var t = (cmap.varGlyphIndexMap || [])[item.vsCode] || {};
            var m = t[item.charCode];
            if (m === -1) {
              chars[item.charCode] = chars[item.charCode] || {
                item: {
                  type: 'char', isUnicode: true,
                  charCode: item.charCode,
                },
                operator: {type: 'cmaps', cmaps: []},
              };
              chars[item.charCode].operator.cmaps.push (cmap);
            } else if (m != null) {
              glyphs[m] = glyphs[m] || {
                item: {
                  type: 'glyph', glyphID: m,
                },
                operator: {type: 'cmaps', cmaps: []},
              };
              glyphs[m].operator.cmaps.push (cmap);
            } // else, not found
          }); // cmap

            if (chars.length || glyphs.length) {
              return {
                operation: 'fork',
                lines: Object.values (chars).concat (Object.values (glyphs)),
              };
            } else {
              return {
                operation: 'replace',
                by: {
                  type: 'char', isUnicode: true, isVSFallback: true,
                  charCode: item.charCode,
                },
                operator: {type: 'cmap-no-match'},
              };
            }
          }, // vs
        }, {
          name: 'Character to glyph',
        });

        changed = changed || iteration ({
          default: (item, ops) => {
            if (font.tables.os2.usDefaultChar) { // defined and non-zero
              return {
                operation: 'replace',
                operator: {type: 'OS/2-default'},
                by: {type: 'char', isUnicode: true, isDefault: true,
                     isFallback: item.isFallback,
                     charCode: font.tables.os2.usDefaultChar},
              };
            } else {
              return {
                operation: 'replace',
                by: {type: 'glyph', glyphID: 0, isDefault: true,
                     isFallback: item.isFallback},
              };
            }                         
          },
          break: (item, ops) => {
            if (font.tables.os2.usBreakChar) { // defined and non-zero
              return {
                operation: 'replace',
                operator: {type: 'OS/2-break'},
                by: {type: 'char', isUnicode: true,
                     charCode: font.tables.os2.usBreakChar},
              };
            } else {
              return {
                operation: 'replace',
                by: {type: 'default', isFallback: true},
              };
            }                         
          },
        }, {
          name: 'Resolve character references',
        });

        if (!changed) break;
      } // while

      this.lookups.filter (_ => _.table === 0).forEach (({lookup, feature}) => {
        var lookupType = lookup.lookupType;
        var sts = lookup.subtables;
        if (lookupType === 7) {
          sts = [];
          lookupType.subtables.forEach (st => {
            if (sts.length && lookupType !== st.lookupType) {
              // broken
              return;
            }
            lookupType = st.lookupType;
            sts.push (st);
          });
        }
        
        iteration ({
          glyph: (item, ops) => {
            if (lookupType === 1) {
              var newID = OT.gsubLookup1 (font, lookup, sts, item.glyphID);
              if (newID === -1) return null; // unchanged

              return {
                operation: 'replace',
                operator: {type: 'lookup', lookup, feature},
                by: {type: 'glyph', glyphID: newID,
                     isDefault: item.isDefault,
                     isVSFallback: item.isVSFallback,
                     isFallback: item.isFallback},
              };
            } else if (lookupType === 2) {
              var newIDs = OT.gsubLookup2 (font, lookup, sts, item.glyphID);
              if (!newIDs) return null; // unchanged
              
              return {
                operation: 'replace',
                operator: {type: 'lookup', lookup, feature},
                by: {type: 'glyph', glyphID: newIDs.shift (),
                     isDefault: item.isDefault,
                     isVSFallback: item.isVSFallback,
                     isFallback: item.isFallback},
                append: newIDs.map (_ => {
                  return {
                    item: {type: 'glyph', glyphID: _,
                           isDefault: item.isDefault,
                           isVSFallback: item.isVSFallback,
                           isFallback: item.isFallback},
                  };
                }),
              };
            } else if (lookupType === 3) {
              var newIDs = OT.gsubLookup3 (font, lookup, sts, item.glyphID);
              if (!newIDs) return null; // unchanged

              return {
                operation: 'fork',
                lines: newIDs.map (_ => {
                  return {
                    operator: {type: 'lookup', lookup, feature},
                    item: {type: 'glyph', glyphID: _,
                           isDefault: item.isDefault,
                           isVSFallback: item.isVSFallback,
                           isFallback: item.isFallback},
                  };
                }),
              };
            } else if (lookupType === 4) {
              var newID = OT.gsubLookup4 (font, lookup, sts, item.glyphID, ops);
              if (newID === -1) return null; // unchanged

              return {
                operation: 'replace',
                operator: {type: 'lookup', lookup, feature},
                by: {type: 'glyph', glyphID: newID,
                     isDefault: item.isDefault,
                     isVSFallback: item.isVSFallback,
                     isFallback: item.isFallback},
                skipNextItems: true,
              };
            } else if (lookupType === 5) {
              var news = OT.gsubLookup5 (font, lookup, sts, item.glyphID, ops);
              if (!news.length) return null; // unchanged

              news = news.map (_ => {
                return _[0].map (item => {
                  return [item, _[1]];
                });
              }).flat ();
              return {
                operation: 'replace',
                operator: {type: 'lookup', lookup, feature},
                byOperators: news[0][1] ? news[0][1].map (_ => {
                  return {type: 'lookup', lookup: _};
                }): [],
                by: {type: 'glyph', glyphID: news.shift ()[0],
                     isDefault: item.isDefault,
                     isVSFallback: item.isVSFallback,
                     isFallback: item.isFallback},
                append: news.map (_ => {
                  return {
                    item: {type: 'glyph', glyphID: _[0],
                           isDefault: item.isDefault,
                           isVSFallback: item.isVSFallback,
                           isFallback: item.isFallback},
                    operators: _[1] ? _[1].map (_ => {
                      return {type: 'lookup', lookup: _};
                    }): [],
                  };
                }),
                skipNextItems: true,
              };
            } else if (lookupType === 6) {
              var news = OT.gsubLookup6 (font, lookup, sts, item.glyphID, ops);
              if (!news.length) return null; // unchanged

              news = news.map (_ => {
                return _[0].map (item => {
                  return [item, _[1]];
                });
              }).flat ();
              return {
                operation: 'replace',
                operator: {type: 'lookup', lookup, feature},
                byOperators: news[0][1] ? news[0][1].map (_ => {
                  return {type: 'lookup', lookup: _};
                }): [],
                by: {type: 'glyph', glyphID: news.shift ()[0],
                     isDefault: item.isDefault,
                     isVSFallback: item.isVSFallback,
                     isFallback: item.isFallback},
                append: news.map (_ => {
                  return {
                    item: {type: 'glyph', glyphID: _[0],
                           isDefault: item.isDefault,
                           isVSFallback: item.isVSFallback,
                           isFallback: item.isFallback},
                    operators: _[1] ? _[1].map (_ => {
                      return {type: 'lookup', lookup: _};
                    }): [],
                  };
                }),
                skipNextItems: true,
              };
            } else if (lookupType === 8) {
              // XXX
            } // lookupType

            return null;
          }, // glyph
        }, {
          name: 'Lookup GSUB',
        });
      });
      
      this.lookups.filter (_ => _.table === 1).forEach (({lookup, feature}) => {
        var lookupType = lookup.lookupType;
        var sts = lookup.subtables;
        if (lookupType === 9) {
          sts = [];
          lookupType.subtables.forEach (st => {
            if (sts.length && lookupType !== st.extensionLookupType) {
              // broken
              return;
            }
            lookupType = st.extensionLookupType;
            sts.push (st);
          });
        }
        
        iteration ({
          glyph: (item, ops) => {
            if (lookupType === 1) {
              var newValue = OT.gposLookup1 (font, lookup, sts, item.glyphID, ops);
              if (!newValue) return null; // unchanged

              newValue.feature = feature;
              return {
                operation: 'modify',
                operator: {type: 'lookup', lookup, feature},
                by: newValue,
              };
            } else if (lookupType === 2) {
              var news = OT.gposLookup2 (font, lookup, sts, item.glyphID, ops);
              if (!news) return null; // unchanged

              news.forEach (_ => _.feature = feature);
              return {
                operation: 'modify',
                operator: {type: 'lookup', lookup, feature},
                by: news.shift (),
                nexts: news.map (_ => {
                  return {
                    item: _,
                  };
                }),
                skipNextItems: !!news[0].value,
              };
            } else if (lookupType === 3) {
              var newValue = OT.gposLookup3 (font, lookup, sts, item.glyphID, ops);
              if (!newValue) return null; // unchanged
              
              newValue.feature = feature;
              return {
                operation: 'modify',
                operator: {type: 'lookup', lookup, feature},
                by: newValue,
              };
            } else if (lookupType === 4) {
              var news = OT.gposLookup4 (font, lookup, sts, item.glyphID, ops);
              if (!news) return null; // unchanged

              news.forEach (_ => _.feature = feature);
              return {
                operation: 'modify',
                operator: {type: 'lookup', lookup, feature},
                by: news[1],
                prevBy: news[0],
              };
            } else if (lookupType === 5) {
              //XXX
            } else if (lookupType === 6) {
              var news = OT.gposLookup6 (font, lookup, sts, item.glyphID, ops);
              if (!news) return null; // unchanged

              news.forEach (_ => _.feature = feature);
              return {
                operation: 'modify',
                operator: {type: 'lookup', lookup, feature},
                by: news[1],
                prevBy: news[0],
              };
            } else if (lookupType === 7) {
              var news = OT.gposLookup7 (font, lookup, sts, item.glyphID, ops);
              if (!news) return null; // unchanged

              news.forEach (_ => _.feature = feature);
              return {
                operation: 'modify',
                operator: {type: 'lookup', lookup, feature},
                by: news.shift (),
                nexts: news,
              };
            } else if (lookupType === 8) {
              var news = OT.gposLookup8 (font, lookup, sts, item.glyphID, ops);
              if (!news) return null; // unchanged

              news.forEach (_ => _.feature = feature);
              return {
                operation: 'modify',
                operator: {type: 'lookup', lookup, feature},
                by: news.shift (),
                nexts: news,
              };
            } // else, unknown

            return null; // unchanged
          }, // glyph
        }, {
          name: 'Lookup GPOS',
        });
      });

      var cmapsSteps = {};
      var normalizeStep = step => {
        if (step.type === 'cmaps') {
          var key = step.cmaps.map (_ => _.index).sort ((a, b) => a - b).join (' ');
          if (cmapsSteps[key]) {
            return cmapsSteps[key];
          } else {
            return cmapsSteps[key] = step;
          }
        } else {
          return step;
        }
      }; // normalizeStep
      
      //console.log(seqs);
      seqs.forEach (seq => {
        var table = document.createElement ('table');
        var tbody = document.createElement ('tbody');
        table.appendChild (tbody);
        container.appendChild (table);

        seq.forEach (item => {
          item.stepses.forEach (steps => {
            for (var i = 0; i < steps.length; i++) {
              var step = normalizeStep (steps[i]);

              var tr = tbody.rows[i];
              if (!tr) {
                tr = document.createElement ('tr');
                tr.colCount = 0;
                tbody.appendChild (tr);
                tr.steps = steps; // for dev
              }
              var xCount = i > 0 ? tbody.rows[0].colCount - 1 : 0;
              while (tr.colCount < xCount) {
                var td = document.createElement ('td');
                tr.appendChild (td);
                tr.colCount++;
              }
              if (tr.cells.length && tr.cells[tr.cells.length-1].step === step) {
                tr.cells[tr.cells.length-1].colSpan++;
                tr.colCount++;
                continue;
              }
              var s = document.createElement ('td');
              s.step = step;
              tr.appendChild (s);
              tr.colCount++;

              step.idPrefix = this.idPrefix;
              if (step.type === 'vs') {
                step.string = String.fromCodePoint (step.charCode) +
                              String.fromCodePoint (step.vsCode);
                step.charCodes = [
                  {charCode: step.charCode, isUnicode: true,
                   isUnicodeAttr: ''},
                  {charCode: step.vsCode, isUnicode: true,
                   isUnicodeAttr: ''},
                ];
              } else if (step.type === 'glyph') {
                if (!font.glyphs.glyphs[step.glyphID]) {
                  step.notFound = true;
                }
              }
                  
              var t = document.querySelector ('#glyph-viewer-step-' + step.type + (step.values ? '-values' : '') + '-template');
              if (!t) throw step;
              s.appendChild (t.content.cloneNode (true));
              s.className = 'glyph-viewer-step';
              s.setAttribute ('glyph-viewer-step-type', step.type);
              $fill (s, step);
              s.querySelectorAll ('.glyph-button').forEach (_ => _.onclick = () => {
                var ev = new Event ('otvShowGlyph', {bubbles: true});
                ev.glyphID = step.glyphID;
                ev.values = step.values;
                this.dispatchEvent (ev);
              });
            } // step
          }); // steps
        }); // item
      }); // seq
    }, // _search

  },
}); // <glyph-viewer>

    defineElement ({
      name: 'glyph-class',
      fill: 'idlattribute',
      props: {
        pcInit: function () {
          //this.font
          //this.idPrefix
          this._init ();

          var v = this.value;
          Object.defineProperty (this, 'value', {
            get: () => v,
            set: (newValue) => { v = newValue; this.update () },
          });
          this.update ();
        },
        _init: function () {
          var t = document.querySelector ('#glyph-class-template');
          this.appendChild (t.content.cloneNode (true));
          
          var p = this.parentNode;
          while (p && !p.font) p = p.parentNode;
          if (p) {
            this.font = p.font;
            this.idPrefix = p.idPrefix;
          }
        }, // _init
        update: function () {
          var c = this.value;
          if (!c) return this.hidden = true;
          this.hidden = false;

          var container = this.querySelector ('.items');
          container.textContent = '';

          $fill (this, c);

          var classes = OT.glyphClassToClassGlyphList (c);
          
          Object.keys (classes).forEach (cls => {
            var p = document.createElement ('p');
            p.innerHTML = 'Glyph class <code></code>';
            p.lastChild.textContent = cls;
            container.appendChild (p);
            
            var lv = document.createElement ('list-viewer');
            lv.setAttribute ('limit', 10);
            lv.type = 'glyphClass';
            lv.setAttribute ('listtitle', 'Glyphs');
            lv.items = classes[cls].map (_ => { return {glyphID: _} });
            container.appendChild (lv);
          });
        }, // update
      },
    }); // <glyph-class>

    defineElement ({
      name: 'list-viewer',
      props: {
        pcInit: function () {
          //this.font
          //this.cmap
          //this.lookup
          //this.subtable
          //this.idPrefix
          this.offset = 0;
          this.limit = parseInt (this.getAttribute ('limit')) || 100;
          this._init ();
          
      this.shown = new Promise (ok => {
        var ob = new IntersectionObserver ((entries) => {
          if (entries[0].intersectionRatio <= 0) return;
          
          ok ();
          ob.disconnect ();
        });
        ob.observe (this);
      });

          var t = this.type || [];
          Object.defineProperty (this, 'type', {
            get: () => t,
            set: (newValue) => { t = newValue; this.update () },
          });
          this.update ();
        }, // pcInit
        _init: function () {
          var p = document.createElement ('p');
          p.className = 'pager';
          p.innerHTML = `
            <span data-field=title></span>
            <a href=javascript: class=list-prev>&lt;&lt;</a>
            [<data data-field=start></data>,
            <data data-field=end></data>]
            <a href=javascript: class=list-next>>></a>
            <input type=number name=offset>
            /
            <data data-field=totalCount></data>
          `;
          p.querySelectorAll ('.list-prev').forEach (_ => _.onclick = () => this.prevPage ());
          p.querySelectorAll ('.list-next').forEach (_ => _.onclick = () => this.nextPage ());
          p.querySelectorAll ('input[name=offset]').forEach (_ => _.oninput = () => this.setOffset (_.valueAsNumber));
          this.appendChild (p);

          var ul = document.createElement ('ul');
          this.appendChild (ul);

          var p = this.parentNode;
          while (p && !p.font) p = p.parentNode;
          if (p) {
            this.font = p.font;
            this.idPrefix = p.idPrefix;
          }
        }, // _init
        update: async function () {
          await this.shown;

          clearTimeout (this._updateTimer);
          this._updateTimer = setTimeout (() => this._update (), 500);
        }, // update
        _update: function () {
          if (!this.type) return;

          if (this['_' + this.type + '_count']) {
            this._totalCount = this['_' + this.type + '_count'] ();
          } else {
            throw new Error ("Bad list-viewer type: |"+this.type+"|");
          }
          this.setAttribute ('type', this.type);
          
          var page = this._page ();
          this.querySelectorAll ('.pager').forEach (p => {
            $fill (p, page);
          });
          var list = this.querySelector ('ul');
          list.textContent = '';

          var itemTemplate = document.querySelector ('#list-'+this.type+'-template');
          var items = this['_' + this.type + '_items'] (page);
          items.forEach (item => {
            var li = document.createElement ('li');
            li.appendChild (itemTemplate.content.cloneNode (true));
            if (item.isUnicode) item.isUnicodeAttr = '';
            if (!item.vsCode) item.vsCodeHidden = '';
            if (item.charCode != null) item.charCodes = [
              {charCode: item.charCode, isUnicode: item.isUnicode,
               isUnicodeAttr: item.isUnicode ? '' : undefined},
            ];
            if (item.vsCode) item.charCodes.push ({
              charCode: item.vsCode, isUnicode: true,
              isUnicodeAttr: '',
            });
            if (item.toCharCode == null) item.toCharCodeHidden = '';
            if (!item.glyph) item.glyphHidden = '';
            item.idPrefix = this.idPrefix;

            $fill (li, item);

            if (item.glyphs && item.values)
            li.addEventListener ('click', ev => {
              if (ev.target.classList.contains ('glyph-button')) {
                var v = new Event ('otvShowGlyph', {bubbles: true});
                var index = parseInt (ev.target.getAttribute ('data-index'));
                v.glyphID = item.glyphs[index].glyphID;
                v.values = [item.values[index]];
                this.dispatchEvent (v);
              }
            });
            
            list.appendChild (li);
          });
        }, // update
        prevPage: function () {
          this.offset -= this.limit;
          this.update ();
        },
        nextPage: function () {
          this.offset += this.limit;
          this.update ();
        },
        setOffset: function (v) {
          this.offset = parseInt (v) || 0;
          this.update ();
        }, // setOffset
        _page: function () {
          var totalCount = this._totalCount;
          var start = this.offset;
          if (totalCount <= start) this.offset = start = totalCount - 1;
          if (start < 0) this.offset = start = 0;
          var end = start + this.limit - 1;
          if (totalCount <= end) end = totalCount - 1;
          return {
            title: this.getAttribute ('listtitle'),
            start,
            end,
            totalCount,
          };
        },

        _glyphs_count: function () {
          return this.font.numGlyphs;
        },
        _glyphs_items: function (page) {
          var items = [];
          for (var i = page.start; i <= page.end; i++) {
            items.push ({
              glyphID: i,
              glyph: this.font.glyphs.get (i),
            });
          }
          return items;
        },

        _glyphNames_count: function () {
          return Object.keys (this.font.glyphNameToID || {}).length;
        },
        _glyphNames_items: function (page) {
          var list = this.font.glyphNameToID || {};
          var names = Object.keys (list).sort ((a, b) => a < b ? -1 : +1);
          return names.slice (page.start, page.end + 1).map (glyphName => {
            return {
              glyphName,
              glyphID: list[glyphName],
              glyph: this.font.glyphs.get (list[glyphName]),
            };
          });
        },

        _cmap_count: function () {
          return this.cmap.glyphNumber;
        },
        _cmap_items: function (page) {
          var cmap = this.cmap;

          var lists = [[cmap.glyphIndexMap || [], null]].concat (Object.keys (cmap.varGlyphIndexMap || []).sort ((a, b) => a - b).map (_ => [cmap.varGlyphIndexMap[_], _]));

          var start = page.start;
          var end = page.end;
          var items = [];
          for (var i = 0; i < lists.length; i++) {
            var list = lists[i];
            var keys = Object.keys (list[0]).sort ((a, b) => a - b);
            var subitems = keys.slice (start, end + 1);
            items = items.concat (subitems.map (_ => {
              return [_, list[0][_], list[1]];
            }));
            start -= keys.length;
            end -= keys.length;
            if (end < 0) break;
            if (start < 0) start = 0;
          }
          
          return items.map (_ => {
            //XXX cmap.isUnicode
            if (_[1] === -1) {
              return {
                charCode: _[0],
                vsCode: _[2],
                toCharCode: _[0],
                isUnicode: true,
              };
            } else {
              return {
                charCode: _[0],
                vsCode: _[2],
                glyphID: _[1],
                glyph: this.font.glyphs.get (_[1]),
                isUnicode: _[2] ? true : undefined,
              };
            }
          });
        },

        _GSUBLookupSubtable_count: function () {
          return OT.gsubLookupSubtableCount (this.lookup, this.subtable);
        },
        _GSUBLookupSubtable_items: function (page) {
          return OT.gsubLookupSubtableItems
              (this.font, this.lookup, this.subtable, page);
        },
        _GPOSLookupSubtable_count: function () {
          return OT.gposLookupSubtableCount (this.lookup, this.subtable);
        },
        _GPOSLookupSubtable_items: function (page) {
          return OT.gposLookupSubtableItems
              (this.font, this.lookup, this.subtable, page);
        },

        _glyphClass_count: function () {
          return this.items.length;
        },
        _glyphClass_items: function (page) {
          return this.items.slice (page.start, page.end + 1);
        },
      },
    }); // <list-viewer>

    defineElement ({
      name: 'glyph-data',
      props: {
        pcInit: function () {
          //this.font
          //this.idPrefix
          this._init (),
          this.show (null, {});
        },
        _init: function () {
          var t = document.querySelector ('#glyph-data');
          var id = this.id = ('element-' + Math.random ()).replace (/\./g, '');
          this.appendChild (t.content.cloneNode (true));

          var style = document.createElement ('style');
          document.head.appendChild (style);

          this.restyle = () => {
            var m = [];
            this.querySelectorAll ('input[name=shown]').forEach (_ => {
              if (!_.checked) m.push ('#' + id + ' svg .' + _.value + '{display:none}');
            });
            style.textContent = m.join ('');
          };
          this.oninput = () => this.restyle ();
          
          var p = this.parentNode;
          while (p && !p.font) p = p.parentNode;
          if (p) {
            this.font = p.font;
            this.idPrefix = p.idPrefix;
          }
        }, // _init

        show: function (glyphID, opts) {
          if (glyphID == null) return this.hidden = true;

          var font = this.font;
          var glyph = this.glyph = OT.getGlyph (font, glyphID);
          var glyphName = (font.tables.post.glyphIDToName || {})[glyphID]; // or undefined

    var glyphClass = OT.glyphClassGet
        ((font.tables.gdef || {}).classDef, glyphID) || 0;
    var markAttachGlyphClass = OT.glyphClassGet
        ((font.tables.gdef || {}).markAttachClassDef, glyphID) || 0;

          var values = this.values = opts.values || [];
          var posValues = this.posValues = {};
          values.forEach (v => {
            if (v.value) {
              if (posValues.xAdvance === undefined &&
                  v.value.xAdvance != null) {
                posValues.xAdvance = v.value.xAdvance;
                posValues.xAdvanceFeature = v.feature; // or none
              }
              if (posValues.yAdvance === undefined &&
                  v.value.yAdvance != null) {
                posValues.yAdvance = v.value.yAdvance;
                posValues.yAdvanceFeature = v.feature; // or none
              }
              if (posValues.xPlacement === undefined &&
                  v.value.xPlacement != null) {
                posValues.xPlacement = v.value.xPlacement;
                posValues.xPlacementFeature = v.feature; // or none
              }
              if (posValues.yPlacement === undefined &&
                  v.value.yPlacement != null) {
                posValues.yPlacement = v.value.yPlacement;
                posValues.yPlacementFeature = v.feature; // or none
              }
            }
            if (!posValues.anchor && v.anchor) {
              posValues.anchor = v.anchor;
              posValues.anchorFeature = v.feature; // or none
            }
            if (!posValues.entryAnchor && v.entryAnchor) {
              posValues.entryAnchor = v.entryAnchor;
              posValues.entryAnchorFeature = v.feature; // or none
              posValues.rtl = v.rtl;
            }
            if (!posValues.exitAnchor && v.exitAnchor) {
              posValues.exitAnchor = v.exitAnchor;
              posValues.exitAnchorFeature = v.feature; // or none
              posValues.rtl = v.rtl;
            }
          });
          
          $fill (this, {
            glyph, glyphName, glyphClass, markAttachGlyphClass,
            glyphID, posValues, glyphIDAndPosValues: [glyphID, posValues],
            font,
          });

          this.hidden = false;
          this.restyle ();

          if (opts.scroll) this.scrollIntoView ({
            block: 'end',
          });
        }, // show
      },
    }); // <glyph-data>

    function dumpLookup (font, ttag, feature, lookup, ps, prefix, opts) {
      var t = document.querySelector ('#'+ttag+'-lookup-template');
      var s = document.createElement ('section');
      s.className = 'subtable';
      s.appendChild (t.content.cloneNode (true));

      $fill (s, lookup);
      if (opts.nested) {
        s.classList.toggle ('nested', true);
      } else {
        s.querySelectorAll ('.nested').forEach (_ => _.remove ());
      }

      var ts = document.querySelector ('#'+ttag+'-lookup-subtable-template');
      var sc = s.querySelector ('.subtables');
      lookup.subtables.forEach (sub => {
        var ss = document.createElement ('section');
        ss.className = 'subtable';
        ss.appendChild (ts.content.cloneNode (true));

        var container = ss.querySelector ('.classes');
        if (sub.inputClassDef || sub.backtrackClassDef || sub.lookaheadClassDef) {
          if (sub.backtrackClassDef === sub.inputClassDef) {
            ss.querySelectorAll ('[data-field=backtrackClassDef]').forEach (_ => {
              var x = document.createTextNode ('(Same as input class)');
              _.parentNode.replaceChild (x, _);
            });
          }
          if (sub.lookaheadClassDef === sub.inputClassDef) {
            ss.querySelectorAll ('[data-field=lookaheadClassDef]').forEach (_ => {
              var x = document.createTextNode ('(Same as input class)');
              _.parentNode.replaceChild (x, _);
            });
          }
        } else {
          container.remove ();
        }

        $fill (ss, sub);

    ss.querySelectorAll ('list-viewer').forEach (_ => {
      _.type = ttag + 'LookupSubtable';
      _.classList.toggle (ttag, true);
      _.lookup = lookup;
      _.subtable = sub;
    });

    sc.appendChild (ss);
  });

      s.querySelectorAll ('glyph-viewer').forEach (_ => {
        _.lookups = [
          {lookup, feature, table: ttag === 'GSUB' ? 0 : 1}, // feature can be null
        ];
      });
      
      ps.appendChild (s);
    } // dumpLookup

      var dumpSubtables = {};

      dumpSubtables.name = (font, ps, prefix) => {
        var nameTable = ps.querySelector ('.names');
        $fill (nameTable.caption, font.tables.name);
        var ntc = nameTable.querySelector ('template');
        var ntb = nameTable.tBodies[0];
        font.tables.name.records.sort ((a, b) => a.nameID - b.nameID).forEach (n => {
          var tr = document.createElement ('tr');
          tr.appendChild (ntc.content.cloneNode (true));
          n["platformID-encodingID"] = n.platformID + '-' + n.encodingID;
          n["platformID-languageID"] = n.platformID + '-' + n.languageID;
          $fill (tr, n);
          ntb.appendChild (tr);
        });
      }; // name
      
      dumpSubtables.BASE = (font, ps, prefix) => {
        ps.querySelectorAll ('table[data-key]').forEach (table => {
          var key = table.getAttribute ('data-key');
          var axis = font.tables.base[key] || {};

          var trs = table.tHead.rows;
          axis.baseScriptRecords.forEach (sr => {
            var th = document.createElement ('th');
            th.colspan = 1 + sr.baseScript.baseLangSysRecords.length;
            var code = document.createElement ('code');
            code.className = 'tag';
            code.textContent = sr.baseScriptTag;
            th.appendChild (code);
            trs[0].appendChild (th);

            trs[1].appendChild (document.createElement ('th'));
            sr.baseScript.baseLangSysRecords.forEach (lsr => {
              var th = document.createElement ('th');
              var code = document.createElement ('code');
              code.className = 'tag';
              code.textContent = lsr.baseLangSysTag;
              th.appendChild (code);
              trs[1].appendChild (th);

              // XXX
            });
            // XXX sr.baseScript.defaultMinMax
          });

          var tbody = table.tBodies[0];
          for (var i = 0; i < (axis.baselineTags || []).length; i++) {
            var tr = document.createElement ('tr');
            var th = document.createElement ('th');
            var code = document.createElement ('code');
            code.className = 'tag';
            code.textContent = axis.baselineTags[i];
            th.appendChild (code);
            tr.appendChild (th);

            axis.baseScriptRecords.forEach (sr => {
              var d = sr.baseScript.baseValues.defaultBaselineIndex;
              var coord = sr.baseScript.baseValues.baseCoords[i] || {};
              var td = document.createElement ('td');
              td.innerHTML = '<dl><div><dt><code>baseCoordFormat</code><dd><data data-field=baseCoordFormat></data></div><div><dt><code>coordinate</code><dd><data data-field=coordinate></data></div><div><dt>is default<dd><enum-value data-field=isDefault></enum-value></div></dl>';
              coord.isDefault = d === i;
              $fill (td, coord);
              tr.appendChild (td);
            });

            //XXX itemVarStore

            tbody.appendChild (tr);
          }
        });
      }; // BASE

    var getFeatureLink = (prefix, table) => (i) => {
      var feature = table.features[i] || {};
      var a = document.createElement ('a');
      a.href = '#' + prefix + '-GSUB-feature-' + feature.index;
      a.innerHTML = '#<span></span> (<code class=tag></code>)';
      a.children[0].textContent = feature.index;
      a.children[1].textContent = feature.tag;
      return a;
    }; // getFeaturLinks
    
    dumpSubtables.GSUB = (font, ps, prefix) => {
      var table = ps.querySelector ('.gsub-scripts');
      var headTrs = table.tHead.rows;
      var bodyTrs = table.tBodies[0].rows;
      var featureLink = getFeatureLink (prefix, font.tables.gsub);
      font.tables.gsub.scripts.forEach (sr => {
          var th = document.createElement ('th');
          th.colSpan = 1 + sr.script.langSysRecords.length;
          var code = document.createElement ('code');
          code.className = 'tag';
          code.textContent = sr.tag;
          th.appendChild (code);
          headTrs[0].appendChild (th);

          headTrs[1].appendChild (document.createElement ('th'));
          sr.script.langSysRecords.forEach (lsr => {
            var th = document.createElement ('th');
            var code = document.createElement ('code');
            code.className = 'tag';
            code.textContent = lsr.tag;
            th.appendChild (code);
            headTrs[1].appendChild (th);

            // XXX
          });

          [sr.script.defaultLangSys].concat (sr.script.langSysRecords.map (_ => _.langSys)).forEach (ls => {
            var req = ls.reqFeatureIndex;
            var td = document.createElement ('td');
            if (req === 0xFFFF) {
              td.textContent = '-';
            } else {
              td.appendChild (featureLink (req));
            }
            bodyTrs[0].appendChild (td);

            var td = document.createElement ('td');
            ls.featureIndexes.forEach (i => {
              td.appendChild (featureLink (i));
              td.appendChild (document.createTextNode (' '));
            });
            bodyTrs[1].appendChild (td);
          });
        });

        var features = font.tables.gsub.features;
        insertSubmenuItems (prefix, 'GSUB', features);
        var lookups = font.tables.gsub.lookups;
        var ft = document.querySelector ('#GSUB-feature-template');
        for (var i = 0; i < features.length; i++) {
          var feature = features[i];
          var fs = document.createElement ('section');
          fs.className = 'subtable';
          fs.id = prefix + '-GSUB-feature-' + feature.index;
          fs.appendChild (ft.content.cloneNode (true));
          $fill (fs, {feature});

          var gvs = fs.querySelectorAll ('glyph-viewer');
          var fLookups = [];

          var container = fs.querySelector ('.subtables');
          feature.feature.lookupListIndexes.forEach (j => {
            var lookup = lookups[j] || {};
            fLookups.push (lookup);
            lookup.seen = true;
            dumpLookup (font, 'GSUB', feature, lookup, container, prefix, {});

            lookup.subtables.forEach (st => {
              (st.lookupRecords || []).forEach (lr => {
                var lookup = lookups[lr.lookupListIndex] || {};
                lookup.seen = true;
                dumpLookup (font, 'GSUB', feature, lookup, container, prefix, {
                  nested: true,
                });
              });
              (st.chainClassSet || st.classSets || st.chainRuleSets || []).forEach (x => {
                (x || []).forEach (y => {
                  (y.lookupRecords || []).forEach (lr => {
                    var lookup = lookups[lr.lookupListIndex] || {};
                    lookup.seen = true;
                    dumpLookup (font, 'GSUB', feature, lookup, container, prefix, {
                      nested: true,
                    });
                  });
                });
              });
            });
          });

          gvs.forEach (_ => {
            _.lookups = fLookups.map (_ => {
              return {feature, lookup: _, table: 0 /* GSUB */};
            });
          });
          
          ps.appendChild (fs);
        } // features

        lookups.forEach (lookup => {
          if (lookup.seen) return;
          dumpLookup (font, 'GSUB', null, lookup, ps, prefix, {});
        });
      }; // GSUB

      dumpSubtables.GPOS = (font, ps, prefix) => {
        var table = ps.querySelector ('.gpos-scripts');
        var headTrs = table.tHead.rows;
        var bodyTrs = table.tBodies[0].rows;
        var featureLink = getFeatureLink (prefix, font.tables.gpos);
        font.tables.gpos.scripts.forEach (sr => {
          var th = document.createElement ('th');
          th.colSpan = 1 + sr.script.langSysRecords.length;
          var code = document.createElement ('code');
          code.className = 'tag';
          code.textContent = sr.tag;
          th.appendChild (code);
          headTrs[0].appendChild (th);

          headTrs[1].appendChild (document.createElement ('th'));
          sr.script.langSysRecords.forEach (lsr => {
            var th = document.createElement ('th');
            var code = document.createElement ('code');
            code.className = 'tag';
            code.textContent = lsr.tag;
            th.appendChild (code);
            headTrs[1].appendChild (th);

            // XXX
          });

          [sr.script.defaultLangSys].concat (sr.script.langSysRecords.map (_ => _.langSys)).forEach (ls => {
            var req = ls.reqFeatureIndex;
            var td = document.createElement ('td');
            if (req === 0xFFFF) {
              td.textContent = '-';
            } else {
              td.appendChild (featureLink (req));
            }
            bodyTrs[0].appendChild (td);

            var td = document.createElement ('td');
            ls.featureIndexes.forEach (i => {
              td.appendChild (featureLink (i));
              td.appendChild (document.createTextNode (' '));
            });
            bodyTrs[1].appendChild (td);
          });
        });

        var features = font.tables.gpos.features;
        insertSubmenuItems (prefix, 'GPOS', features);
        var lookups = font.tables.gpos.lookups;
        var ft = document.querySelector ('#GPOS-feature-template');
        for (var i = 0; i < features.length; i++) {
          var feature = features[i];
          var fs = document.createElement ('section');
          fs.className = 'subtable';
          fs.id = prefix + '-GPOS-feature-' + feature.index;
          fs.appendChild (ft.content.cloneNode (true));
          $fill (fs, {feature});

          var gvs = fs.querySelectorAll ('glyph-viewer');
          var fLookups = [];

          var container = fs.querySelector ('.subtables');
          feature.feature.lookupListIndexes.forEach (j => {
            var lookup = lookups[j] || {};
            fLookups.push (lookup);
            lookup.seen = true;
            dumpLookup (font, 'GPOS', feature, lookup, container, prefix, {});

            lookup.subtables.forEach (st => {
              (st.lookupRecords || []).forEach (lr => {
                var lookup = lookups[lr.lookupListIndex] || {};
                lookup.seen = true;
                dumpLookup (font, 'GPOS', feature, lookup, container, prefix, {
                  nested: true,
                });
              });
              (st.chainClassSet || st.classSets || st.chainRuleSets || []).forEach (x => {
                (x || []).forEach (y => {
                  (y.lookupRecords || []).forEach (lr => {
                    var lookup = lookups[lr.lookupListIndex] || {};
                    lookup.seen = true;
                    dumpLookup (font, 'GPOS', feature, lookup, container, prefix, {
                      nested: true,
                    });
                  });
                });
              });
            });
          });

          gvs.forEach (_ => {
            _.lookups = fLookups.map (_ => {
              return {feature, lookup: _, table: 1 /* GPOS */};
            });
          });
          
          ps.appendChild (fs);
        } // features

        lookups.forEach (lookup => {
          if (lookup.seen) return;
          dumpLookup (font, 'GPOS', null, lookup, ps, prefix, {});
        });
      }; // GPOS

      dumpSubtables.cmap = (font, ps, prefix) => {
        var cTemplate = document.querySelector ('#cmap-subtable-template');
        font.tables.cmap.subtables.forEach (c => {
          var s = document.createElement ('section');
          s.className = 'subtable';
          s.id = prefix + '-cmap-' + c.index;
          s.appendChild (cTemplate.content.cloneNode (true));
          $fill (s, c);

          s.querySelectorAll ('glyph-viewer').forEach (_ => {
            _.font = font;
            _.cmap = c;
            _.idPrefix = prefix;
            if (_.update) _.update ();
          });

          s.querySelectorAll ('list-viewer').forEach (_ => {
            _.type = 'cmap';
            _.cmap = c;
          });
          
          ps.appendChild (s);
        });

        insertSubmenuItems (prefix, 'cmap', font.tables.cmap.subtables);
      }; // cmap

      dumpSubtables.post = (font, ps, prefix) => {
        ps.querySelectorAll ('list-viewer').forEach (_ => {
          _.type = 'glyphNames';
        });
      }; // post

    dumpSubtables.meta = (font, ps, prefix) => {
      var tb = ps.querySelector ('tbody');
      var tags = Object.keys (font.tables.meta || {});
      for (var i = 0; i < tags.length; i++) {
        var tag = tags[i];
        if (tag.length !== 4) continue;

        var tr = document.createElement ('tr');
        tr.innerHTML = '<th><code class=tag></code><td><data class=text></data>';
        tr.firstChild.firstChild.textContent = tag;
        tr.lastChild.firstChild.textContent = font.tables.meta[tag];
        tb.appendChild (tr);
      }
    }; // meta

      var dumpTable = (parent, font, id, name, key) => {
        var table = font.tables[key];
        var s = document.createElement ('section');
        s.id = id + '-' + name;
        s.className = 'table table-' + name;

        var t = document.querySelector
            (table ? '#table-template' : '#no-table-template');
        s.appendChild (t.content.cloneNode (true));
        var appleKey = name.replace (/\//, '');
        $fill (s, {name, appleKey, msKey: key});

        if (table) {
          var t = document.querySelector ('#' + CSS.escape (name) + '-table-template');
          if (!t) throw new Error ("No template for table |"+name+"|");
          var u = document.createElement ('div');
          u.appendChild (t.content.cloneNode (true));
          table.idPrefix = id;
          $fill (u, table);
          u.querySelectorAll ('char-code').forEach (_ => {
            _.setAttribute ('viewerselector', '#' + CSS.escape (id) + '-glyphs glyph-viewer');
          });
          while (u.firstChild) {
            s.appendChild (u.firstChild);
          }

          var ds = dumpSubtables[name];
          if (ds) dumpSubtables[name] (font, s, id);
        } // has table

        parent.appendChild (s);
      }; // dumpTable

    function insertSubmenuItems (prefix, tag, subItems) {
      var list = document.querySelector ('#' + prefix + ' .table-menu');
      var item;
      for (var i = 0; i < list.children.length; i++) {
        var t = list.children[i];
        var c = t.querySelector ('code');
        if (!c) continue;
        if (c.textContent === tag) {
          item = t;
          break;
        }
      }
      if (!item) throw tag;

      var ul = item.querySelector ('ul');
      if (!ul) {
        ul = document.createElement ('ul');
        item.appendChild (ul);
      }
      var t = document.querySelector ('#'+tag+'-submenu-item-template');
      subItems.forEach (subItem => {
        var li = document.createElement ('li');
        li.appendChild (t.content.cloneNode (true));
        $fill (li, {list: {idPrefix: prefix}, item: subItem});
        ul.appendChild (li);
      });
    } // insertSubmenuItems

  </script>

  <template id=font-template>
    <header>
      <h1 data-field=name></h1>
      <header-menu>
        <a data-href-template="#{id}-summary">Summary</a>
        <a data-href-template="#{id}-glyphs">Glyphs</a>
      </header-menu>
    </header>
    <ul class=table-menu>
      <template>
        <a data-href-template="#{id}"><code class=tag data-field=tag></code></a>
      </template>
    </ul>
    <div class=table-list>
      <section data-id-template="{id}-summary" class="table summary">
        <h1>Summary</h1>

        <dl>
          <div>
            <dt>Tables
            <dd>
              <can-copy><code><item-list data-field=tableList template=item-list-tag-swml-template></item-list></code></can-copy>
          </div>
          <div>
            <dt><code>GSUB</code> features
            <dd>
              <can-copy><code><item-list data-field=gsubFeatureList template=item-list-tag-swml-template></item-list></code></can-copy>
          </div>
          <div>
            <dt><code>GPOS</code> features
            <dd>
              <can-copy><code><item-list data-field=gposFeatureList template=item-list-tag-swml-template></item-list></code></can-copy>
          </div>
          <div>
            <dt><code>GSUB</code> lookups
            <dd>
              <can-copy><code data-field=gsubLookupSummary></code></can-copy>
          </div>
          <div>
            <dt><code>GPOS</code> lookups
            <dd>
              <can-copy><code data-field=gposLookupSummary></code></can-copy>
          </div>
        </dl>
      </section>
      <section data-id-template="{id}-glyphs" class="table glyphs">
        <header>
          <h1>Glyphs</h1>
        </header>
        
        <glyph-viewer></glyph-viewer>
        
        <list-viewer listtitle="Glyphs"></list-viewer>
        
        <glyph-data hidden></glyph-data>
      </section>
    </div>
  </template>

  <template id=table-template>
    <header>
      <h1><code data-field=name></code> table</h1>

      <header-menu>
        <p class=links>Spec:
        <a data-href-template="https://docs.microsoft.com/en-us/typography/opentype/spec/{appleKey}">Microsoft</a>
        <a data-href-template="https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6{appleKey}.html">Apple</a>
        <p class=links>Notes:
        <a data-href-template="https://wiki.suikawiki.org/n/{name}%20(OpenType)">SuikaWiki</a>
      </header-menu>
    </header>
  </template>

  <template id=no-table-template>
    <h1><code data-field=name></code> table</h1>

    <p><code data-field=name></code> table not found.</p>
  </template>
  
  <template id=name-table-template>
    <table class=names>
      <caption>
        Naming table (version <data data-field=tableVersion></data>)
      </caption>
      <thead>
        <tr>
          <th>Name
          <th>Platform
          <th>Language
          <th>Encoding
          <th>String
      <template>
        <td>
          <enum-value data-field=nameID
              label-0="copyright notice (0)"
              label-1="font family name (1)"
              label-2="font subfamily name (2)"
              label-3="unique font identifier (3)"
              label-4="full font name (4)"
              label-5="version string (5)"
              label-6="postscript name (6)"
              label-7="trademark (7)"
              label-8="manufacturer name (8)"
              label-9="designer (9)"
              label-10="description (10)"
              label-11="vendor URL (11)"
              label-12="designer URL (12)"
              label-13="license description (13)"
              label-14="license info URL (14)"
              label-16="typographic family name (16)"
              label-17="typographic subfamily name (17)"
              label-18="compatible full (18)"
              label-19="sample text (19)"
              label-20="postscript cid findfont name (20)"
              label-21="WWS family name (21)"
              label-22="WWS subfamily name (22)"
              label-23="light background palette (23)"
              label-24="dark background palette (24)"
              label-25="variations postscript prefix (25)"
          ></enum-value>  
        <td>
          <enum-value data-field=platformID
              label-0="Unicode (0)"
              label-1="Macintosh (1)"
              label-2="ISO/IEC 10646 (2)"
              label-3="Windows (3)"
          ></enum-value>  
        <td>
          <enum-value data-field=platformID-languageID
              label-1-0="English (0)"
              label-1-1="French (1)"
              label-1-2="German (2)"
              label-1-3="Italian (3)"
              label-1-4="Dutch (4)"
              label-1-11="11 (Japanese)"
              label-1-19="Traditional Chinese (19)"
              label-3-1033="English (US) (0x0409)"
              label-3-1041="Japanese (0x0411)"
              label-3-1028="Chinese (Taiwan) (0x0404)"
              label-3-3076="Chinese (Hong Kong) (0x0C04)"
          ></enum-value>  
        <td>
          <enum-value data-field=platformID-encodingID
              label-0-0="Unicode 1.0 (0)"
              label-0-1="Unicode 1.1 (1)"
              label-0-2="ISO/IEC 10646-1:1993 (2)"
              label-0-3="Unicode 2.0+, BMP only (3)"
              label-0-4="Unicode 2.0+, full repertoire (4)"
              label-1-0="0 (MacRoman)"
              label-1-1="1 (MacJapanese)"
              label-1-2="2 (MacChineseTrad)"
              label-1-3="Korean (3)"
              label-1-4="Arabic (4)"
              label-1-5="Hebrew (5)"
              label-1-6="Greek (6)"
              label-1-7="Russian (7)"
              label-1-8="RSymbol (8)"
              label-1-9="Devanagari (9)"
              label-1-10="Gurmukhi (10)"
              label-1-11="Guarati (11)"
              label-1-12="Oriya (12)"
              label-1-13="Bengali (13)"
              label-1-14="Tamil (14)"
              label-1-15="Telugu (15)"
              label-1-16="Kannada (16)"
              label-1-17="Malayalam (17)"
              label-1-18="Sinhalese (18)"
              label-1-19="Burmese (19)"
              label-1-20="Khmer (20)"
              label-1-21="Thai (21)"
              label-1-22="Laotian (22)"
              label-1-23="Georgian (23)"
              label-1-24="Armenian (24)"
              label-1-25="Simplified Chinese (25)"
              label-1-26="Tibetan (26)"
              label-1-27="Mongolian (27)"
              label-1-28="Geez (28)"
              label-1-29="Slavic (29)"
              label-1-30="Vietnamese (30)"
              label-1-31="Sindhi (31)"
              label-1-32="Uninterpreted (32)"
              label-3-0="Symbol (0)"
              label-3-1="Unicode BMP (1)"
              label-3-2="Shift JIS (2)"
              label-3-3="PRC (3)"
              label-3-4="Big5 (4)"
              label-3-5="Wansung (5)"
              label-3-6="Johab (6)"
              label-3-10="Unicode full repertoire (10)"
          ></enum-value>  
        <td>
          <data class=text data-field=string></data>
      </template>
      <tbody>
    </table>
  </template>

  <!--
     <https://docs.microsoft.com/en-us/typography/opentype/spec/head>
     <https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6head.html>
  -->
  <template id=head-table-template>
    <dl>
      <div>
        <dt>Version
        <dd><data data-field=version></data>
      </div>
      <div>
        <dt><code>indexToLocFormat</code>
        <dd>
          <enum-value data-field=indexToLocFormat
              label-0="0 (Offset16)" label-1="1 (Offset32)"
          ></enum-value>
      </div>
      <div>
        <dt><code>glyphDataFormat</code>
        <dd><enum-value data-field=glyphDataFormat></enum-value>
      </div>
      <div>
        <dt><code>fontRevision</code>
        <dd><data data-field=fontRevision></data>
      </div>
      <div>
        <dt><code>created</code>
        <dd><time data-field=created></time>
      </div>
      <div>
        <dt><code>modified</code>
        <dd><time data-field=modified></time>
      </div>
      <div>
        <dt><code>flags</code>
        <dd>
          <label><input type=checkbox data-checked-field=flags-0 disabled data-filled=checked> baseline at y = 0 (0)</label>
          <label><input type=checkbox data-checked-field=flags-1 disabled data-filled=checked> left sidebearing point at x = 0 (1)</label>
          <label><input type=checkbox data-checked-field=flags-2 disabled data-filled=checked> may depend on point size (2)</label>
          <label><input type=checkbox data-checked-field=flags-3 disabled data-filled=checked> force ppem to integer (3)</label>
          <label><input type=checkbox data-checked-field=flags-4 disabled data-filled=checked> may alter advance width (4)</label>
          <label><input type=checkbox data-checked-field=flags-5 disabled data-filled=checked> vertical (5)</label>
          <label><input type=checkbox data-checked-field=flags-6 disabled data-filled=checked> 6</label>
          <label><input type=checkbox data-checked-field=flags-7 disabled data-filled=checked> requires layout for correct linguistic rendering (7)</label>
          <label><input type=checkbox data-checked-field=flags-8 disabled data-filled=checked> AAT font (8)</label>
          <label><input type=checkbox data-checked-field=flags-9 disabled data-filled=checked> has strong rtl (9)</label>
          <label><input type=checkbox data-checked-field=flags-10 disabled data-filled=checked> has indic-style rearrangement effects (10)</label>
          <label><input type=checkbox data-checked-field=flags-11 disabled data-filled=checked> lossless (11)</label>
          <label><input type=checkbox data-checked-field=flags-12 disabled data-filled=checked> converted (12)</label>
          <label><input type=checkbox data-checked-field=flags-13 disabled data-filled=checked> cleartype (13)</label>
          <label><input type=checkbox data-checked-field=flags-14 disabled data-filled=checked> last resort (14)</label>
          <label><input type=checkbox data-checked-field=flags-15 disabled data-filled=checked> 15</label>
      </div>
      <div>
        <dt><code>macStyle</code>
        <dd>
          <label><input type=checkbox data-checked-field=macStyle-0 disabled data-filled=checked> bold (0)</label>
          <label><input type=checkbox data-checked-field=macStyle-1 disabled data-filled=checked> italic (1)</label>
          <label><input type=checkbox data-checked-field=macStyle-2 disabled data-filled=checked> underline (2)</label>
          <label><input type=checkbox data-checked-field=macStyle-3 disabled data-filled=checked> outline (3)</label>
          <label><input type=checkbox data-checked-field=macStyle-4 disabled data-filled=checked> shadow (4)</label>
          <label><input type=checkbox data-checked-field=macStyle-5 disabled data-filled=checked> condensed (5)</label>
          <label><input type=checkbox data-checked-field=macStyle-6 disabled data-filled=checked> extended (6)</label>
          <label><input type=checkbox data-checked-field=macStyle-7 disabled data-filled=checked> 7</label>
          <label><input type=checkbox data-checked-field=macStyle-8 disabled data-filled=checked> 8</label>
          <label><input type=checkbox data-checked-field=macStyle-9 disabled data-filled=checked> 9</label>
          <label><input type=checkbox data-checked-field=macStyle-10 disabled data-filled=checked> 10</label>
          <label><input type=checkbox data-checked-field=macStyle-11 disabled data-filled=checked> 11</label>
          <label><input type=checkbox data-checked-field=macStyle-12 disabled data-filled=checked> 12</label>
          <label><input type=checkbox data-checked-field=macStyle-13 disabled data-filled=checked> 13</label>
          <label><input type=checkbox data-checked-field=macStyle-14 disabled data-filled=checked> 14</label>
          <label><input type=checkbox data-checked-field=macStyle-15 disabled data-filled=checked> 15</label>
      </div>
      <div>
        <dt><code>unitsPerEm</code>
        <dd><code data-field=unitsPerEm></code> [unit]
      </div>
      <div>
        <dt><var>x</var>
        <dd>[<data data-field=xMin></data>, <data data-field=xMax></data>]
      </div>
      <div>
        <dt><var>y</var>
        <dd>[<data data-field=yMin></data>, <data data-field=yMax></data>]
      </div>
      <div>
        <dt><code>lowestRecPPEM</code>
        <dd><code data-field=lowestRecPPEM></code> [px]
      </div>
      <div>
        <dt><code>fontDirectionHint</code>
        <dd>
          <enum-value data-field=fontDirectionHint
              label-0="0 (fully mixed)"
              label-1="1 (only ltr)"
              label-2="2 (ltr and neutrals)"
              label--1="-1 (only rtl)"
              label--2="-2 (rtl and neutrals)"
          ></enum-value>
      </div>
    </dl>
  </template>

  <template id=meta-table-template>
    <dl>
      <div>
        <dt>Version
        <dd><data data-field=_table.version></data>
      </div>
      <div>
        <dt><code>flags</code>
        <dd><data data-field=_table.flags></data>
      </div>
    </dl>

    <table>
      <thead>
        <tr>
          <th><code>tag</code>
          <th><code>data</code>
      <tbody>
    </table>
  </template>

  <template id=OS/2-table-template>
    <dl>
      <div>
        <dt>Version
        <dd><data data-field=version></data>
      </div>
      <div>
        <dt><code>xAvgCharWidth</code>
        <dd><data data-field=xAvgCharWidth></data> [unit]
      </div>
      <div>
        <dt><code>usWeightClass</code>
        <dd><code data-field=usWeightClass></code>
      </div>
      <div>
        <dt><code>usWidthClass</code>
        <dd><code data-field=usWidthClass></code>
      </div>
      <div>
        <dt><code>fsType</code>
        <dd>
          <enum-value data-field=fsType-0
              label-0="installable (0)"
              label-2="restricted license (2)"
              label-4="preview & print (4)"
              label-8="editable (8)"
              label-12="preview & print, editable (12)"
          ></enum-value>
          <label><input type=checkbox data-checked-field=fsType-4 disabled data-filled=checked> 4</label>
          <label><input type=checkbox data-checked-field=fsType-5 disabled data-filled=checked> 5</label>
          <label><input type=checkbox data-checked-field=fsType-6 disabled data-filled=checked> 6</label>
          <label><input type=checkbox data-checked-field=fsType-7 disabled data-filled=checked> 7</label>
          <label><input type=checkbox data-checked-field=fsType-8 disabled data-filled=checked> no subsetting (8)</label>
          <label><input type=checkbox data-checked-field=fsType-9 disabled data-filled=checked> bitmap embedding only (9)</label>
          <label><input type=checkbox data-checked-field=fsType-10 disabled data-filled=checked> 10</label>
          <label><input type=checkbox data-checked-field=fsType-11 disabled data-filled=checked> 11</label>
          <label><input type=checkbox data-checked-field=fsType-12 disabled data-filled=checked> 12</label>
          <label><input type=checkbox data-checked-field=fsType-13 disabled data-filled=checked> 13</label>
          <label><input type=checkbox data-checked-field=fsType-14 disabled data-filled=checked> 14</label>
          <label><input type=checkbox data-checked-field=fsType-15 disabled data-filled=checked> 15</label>
      </div>
      <div>
        <dt>(<code>ySubscriptXSize</code>, <code>ySubscriptYSize</code>)
        <dd>(<code data-field=ySubscriptXSize></code> [unit],
             <code data-field=ySubscriptYSize></code> [unit])
      </div>
      <div>
        <dt>(<code>ySubscriptXOffset</code>, <code>ySubscriptYOffset</code>)
        <dd>(<code data-field=ySubscriptXOffset></code> [unit],
             <code data-field=ySubscriptYOffset></code> [unit])
      </div>
      <div>
        <dt>(<code>ySuperscriptXSize</code>, <code>ySuperscriptYSize</code>)
        <dd>(<code data-field=ySuperscriptXSize></code> [unit],
             <code data-field=ySuperscriptYSize></code> [unit])
      </div>
      <div>
        <dt>(<code>ySuperscriptXOffset</code>,
             <code>ySuperscriptYOffset</code>)
        <dd>(<code data-field=ySuperscriptXOffset></code> [unit],
             <code data-field=ySuperscriptYOffset></code> [unit])
      </div>
      <div>
        <dt><code>yStrikeoutSize</code>
        <dd><code data-field=yStrikeoutSize></code> [unit]
      </div>
      <div>
        <dt><code>yStrikeoutPosition</code>
        <dd><code data-field=yStrikeoutPosition></code> [unit]
      </div>
      <div>
        <dt><code>sTypoAscender</code>
        <dd><code data-field=sTypoAscender></code>
      </div>
      <div>
        <dt><code>sTypoDescender</code>
        <dd><code data-field=sTypoDescender></code>
      </div>
      <div>
        <dt><code>sTypoLineGap</code>
        <dd><code data-field=sTypoLineGap></code>
      </div>
      <div>
        <dt><code>usWinAscent</code>
        <dd><code data-field=usWinAscent></code>
      </div>
      <div>
        <dt><code>usWinDescent</code>
        <dd><code data-field=usWinDescent></code>
      </div>
      <div>
        <dt><code>sxHeight</code>
        <dd><code data-field=sxHeight></code>
      </div>
      <div>
        <dt><code>sCapHeight</code>
        <dd><code data-field=sCapHeight></code>
      </div>
      <div>
        <dt>[<code>usLowerOpticalPointSize</code>,
             <code>usUpperOpticalPointSize</code>]
        <dd>[<code data-field=usLowerOpticalPointSize data-empty=?></code>,
             <code data-field=usUpperOpticalPointSize data-empty=?></code>]
      </div>
      <div>
        <dt><code>sFamilyClass</code>
        <dd>
          <!-- <https://docs.microsoft.com/en-us/typography/opentype/spec/ibmfc> -->
          <enum-value data-field=sFamilyClass-classID
              label-0="no classification (0)"
              label-1="oldstyle serifs (1)"
              label-2="transitional serifs (2)"
              label-3="modern serifs (3)"
              label-4="clarendon serifs (4)"
              label-5="slab serifs (5)"
              label-7="freeform serifs (7)"
              label-8="sans serif (8)"
              label-9="ornamentals (9)"
              label-10="scripts (10)"
              label-12="symbolic (12)"
          ></enum-value>
          <enum-value data-field=sFamilyClass-classID-subclassID
              label-1-0="no classification (0)"
              label-1-1="IBM rounded legibility (1)"
              label-1-2="garalde (2)"
              label-1-2="garalde (2)"
              label-1-3="venetian (3)"
              label-1-4="modified venetian (4)"
              label-1-5="dutch modern (5)"
              label-1-6="dutch traditional (6)"
              label-1-7="contemporary (7)"
              label-1-8="calligraphic (8)"
              label-1-15="miscellaneous (15)"
              label-8-1="IBM neo-grotesque gothic (1)"
              label-8-2="humanist (2)"
              label-8-3="low-x round geometric (3)"
              label-8-4="high-x round geometric (4)"
              label-8-5="neo-grotesque gothic (5)"
              label-8-6="modified neo-grotesque gothic (6)"
              label-8-9="typewriter gothic (9)"
              label-8-10="matrix (10)"
              label-8-15="miscellaneous (15)"
              label-10-0="no classification (0)"
              label-10-1="unical (1)"
              label-10-2="brush joined (2)"
              label-10-3="formal joined (3)"
              label-10-4="monotone joined (4)"
              label-10-5="calligraphic (5)"
              label-10-6="brush unjoined (6)"
              label-10-7="formal unjoined (7)"
              label-10-8="monotone unjoined (8)"
              label-10-15="miscellaneous (15)"
          ></enum-value>
      </div>
      <div>
        <dt><code>achVendID</code>
        <dd><code class=string data-field=achVendID></code>
      </div>
      <div>
        <dt><code>fsSelection</code>
        <dd>
          <label><input type=checkbox data-checked-field=fsSelection-0 disabled data-filled=checked> ITALIC (0)</label>
          <label><input type=checkbox data-checked-field=fsSelection-1 disabled data-filled=checked> UNDERSCORE (1)</label>
          <label><input type=checkbox data-checked-field=fsSelection-2 disabled data-filled=checked> NEGATIVE (2)</label>
          <label><input type=checkbox data-checked-field=fsSelection-3 disabled data-filled=checked> OUTLINED (3)</label>
          <label><input type=checkbox data-checked-field=fsSelection-4 disabled data-filled=checked> STRIKEOUT (4)</label>
          <label><input type=checkbox data-checked-field=fsSelection-5 disabled data-filled=checked> BOLD (5)</label>
          <label><input type=checkbox data-checked-field=fsSelection-6 disabled data-filled=checked> REGULAR (6)</label>
          <label><input type=checkbox data-checked-field=fsSelection-7 disabled data-filled=checked> USE_TYPO_METRICS (7)</label>
          <label><input type=checkbox data-checked-field=fsSelection-8 disabled data-filled=checked> WWS (8)</label>
          <label><input type=checkbox data-checked-field=fsSelection-9 disabled data-filled=checked> OBLIQUE (9)</label>
          <label><input type=checkbox data-checked-field=fsSelection-10 disabled data-filled=checked> 10</label>
          <label><input type=checkbox data-checked-field=fsSelection-11 disabled data-filled=checked> 11</label>
          <label><input type=checkbox data-checked-field=fsSelection-12 disabled data-filled=checked> 12</label>
          <label><input type=checkbox data-checked-field=fsSelection-13 disabled data-filled=checked> 13</label>
          <label><input type=checkbox data-checked-field=fsSelection-14 disabled data-filled=checked> 14</label>
          <label><input type=checkbox data-checked-field=fsSelection-15 disabled data-filled=checked> 15</label>
      </div>
      <div>
        <dt><code>panose</code>
        <dd>
          <code>bFamilyType</code>
          <enum-value data-field=panose.0
              label-2="Latin text (2)"
              label-3="Latin hand written (3)"
              label-4="Latin decorative (4)"
              label-5="Latin symbol (5)"
          ></enum-value>;
          <code>bSerifStyle</code> <code data-field=panose.1></code>;
          <code>bWeight</code> <code data-field=panose.2></code>;
          <code>bProportion</code> <code data-field=panose.3></code>;
          <code>bContrast</code> <code data-field=panose.4></code>;
          <code>bStrokeVariation</code> <code data-field=panose.5></code>;
          <code>bArmStyle</code> <code data-field=panose.6></code>;
          <code>bLetterform</code> <code data-field=panose.7></code>;
          <code>bMidline</code> <code data-field=panose.8></code>;
          <code>bXHeight</code> <code data-field=panose.9></code>
      </div>
      <div>
        <dt><code>usMaxContext</code>
        <dd><code data-field=usMaxContext></code>
      </div>
      <div>
        <dt><code>usDefaultChar</code>
        <dd><char-code data-field=usDefaultChar isunicode nonzero></char-code>
      </div>
      <div>
        <dt><code>usBreakChar</code>
        <dd><char-code data-field=usBreakChar isunicode nonzero></char-code>
      </div>
      <div>
        <dt>[<code>usFirstCharIndex</code>, 
             <code>usLastCharIndex</code>]
        <dd>[<char-code data-field=usFirstCharIndex></char-code>,
             <char-code data-field=usLastCharIndex></char-code>]
      </div>
    </dl>

    <!--XXX
    <p>Unicode ranges:
    <label><input type=checkbox data-checked-field=ulUnicodeRange1-0 disabled data-filled=checked> Basic Latin (0)</label>
    ...
    <label><input type=checkbox data-checked-field=ulUnicodeRange4-31 disabled data-filled=checked> 127</label>
    <p>ulCodePointRange s:
    -->

  </template>

  <template id=maxp-table-template>
    <dl>
      <div>
        <dt>Version
        <dd><data data-field=version></data>
      </div>
      <div>
        <dt><code>numGlyphs</code>
        <dd><data data-field=numGlyphs></data>
      </div>
      <div>
        <dt><code>maxPoints</code>
        <dd><data data-field=maxPoints></data>
      </div>
      <div>
        <dt><code>maxContours</code>
        <dd><data data-field=maxContours></data>
      </div>
      <div>
        <dt><code>maxCompositePoints</code>
        <dd><data data-field=maxCompositePoints></data>
      </div>
      <div>
        <dt><code>maxCompositeContours</code>
        <dd><data data-field=maxCompositeContours></data>
      </div>
      <div>
        <dt><code>maxZones</code>
        <dd>
          <enum-value data-field=maxPoints
              label-1="do not use Z0 (1)"
              label-2="use Z0 (2)"
          ></enum-value>
      </div>
      <div>
        <dt><code>maxTwilightPoints</code>
        <dd><data data-field=maxTwilightPoints></data>
      </div>
      <div>
        <dt><code>maxStorage</code>
        <dd><data data-field=maxStorage></data>
      </div>
      <div>
        <dt><code>maxFunctionDefs</code>
        <dd><data data-field=maxFunctionDefs></data>
      </div>
      <div>
        <dt><code>maxInstructionDefs</code>
        <dd><data data-field=maxInstructionDefs></data>
      </div>
      <div>
        <dt><code>maxStackElements</code>
        <dd><data data-field=maxStackElements></data>
      </div>
      <div>
        <dt><code>maxSizeOfInstructions</code>
        <dd><data data-field=maxSizeOfInstructions></data>
      </div>
      <div>
        <dt><code>maxComponentElements</code>
        <dd><data data-field=maxComponentElements></data>
      </div>
      <div>
        <dt><code>maxComponentDepth</code>
        <dd><data data-field=maxComponentDepth></data>
      </div>
    </dl>
  </template>

  <template id=post-table-template>
    <dl>
      <div>
        <dt>Version
        <dd><data data-field=version></data>
      </div>
      <div>
        <dt><code>italicAngle</code>
        <dd><data data-field=italicAngle></data> [deg]
      </div>
      <div>
        <dt><code>underlinePosition</code>
        <dd><data data-field=underlinePosition></data>
      </div>
      <div>
        <dt><code>underlineThickness</code>
        <dd><data data-field=underlineThickness></data>
      </div>
      <div>
        <dt><code>isFixedPitch</code>
        <dd>
          <enum-value data-field=isFixedPitch
              label-0="0 (proportional)"
              label-1="1 (not proportional)"
          ></enum-value>
      </div>
      <div>
        <dt>[<code>minMemType42</code>, <code>maxMemType42</code>]
        <dd>[<data data-field=minMemType42></data>,
             <data data-field=maxMemType42></data>]
      </div>
      <div>
        <dt>[<code>minMemType1</code>, <code>maxMemType1</code>]
        <dd>[<data data-field=minMemType1></data>,
             <data data-field=maxMemType1></data>]
      </div>
    </dl>

    <list-viewer listtitle="Glyph names"></list-viewer>
  </template>

  <template id=loca-table-template>
    <p>See <a data-href-template="#{idPrefix}-glyphs">glyphs</a>.
  </template>
  <template id=hmtx-table-template>
    <p>See <a data-href-template="#{idPrefix}-glyphs">glyphs</a>.
  </template>
  <template id=vmtx-table-template>
    <p>See <a data-href-template="#{idPrefix}-glyphs">glyphs</a>.
  </template>
  <template id=glyf-table-template>
    <p>See <a data-href-template="#{idPrefix}-glyphs">glyphs</a>.
  </template>

  <template id=BASE-table-template>
    <dl>
      <div>
        <dt>Version
        <dd><data data-field=version></data>
      </div>
    </dl>

    <p><code>horizAxis</code>:
    <table data-key=horizAxis>
      <thead>
        <tr>
          <th rowspan=2>
            <code>baselineTag</code><br>
            \<br>
            <code>baseScriptTag</code>
        <tr>
      <tbody>
    </table>

    <p><code>vertAxis</code>:
    <table data-key=vertAxis>
      <thead>
        <tr>
          <th>
            <code>baselineTag</code><br>
            \<br>
            <code>baseScriptTag</code>
        <tr>
      <tbody>
    </table>

  </template>

  <template id=GSUB-table-template>
    <table class=gsub-scripts>
      <thead>
        <tr>
          <th rowspan=2 scope=row>Script
        <tr>
      <tbody>
        <tr>
          <th><code>requiredFeature</code>
        <tr>
          <th><code>feature</code>
    </table>

  </template>

  <template id=GPOS-table-template>
    <table class=gpos-scripts>
      <thead>
        <tr>
          <th rowspan=2 scope=row>Script
        <tr>
      <tbody>
        <tr>
          <th><code>requiredFeature</code>
        <tr>
          <th><code>feature</code>
    </table>

  </template>

  <template id=GSUB-submenu-item-template>
    <a data-href-template="#{list.idPrefix}-GSUB-feature-{item.index}">
      <code class=tag data-field=item.tag></code>
    </a>
  </template>

  <template id=GSUB-feature-template>
    <h1>Feature <code class=tag data-field=feature.tag></code></h1>

    <!-- XXX params -->

    <div class=subtables></div>

    <glyph-viewer></glyph-viewer>
  </template>

  <template id=GPOS-submenu-item-template>
    <a data-href-template="#{list.idPrefix}-GPOS-feature-{item.index}">
      <code class=tag data-field=item.tag></code>
    </a>
  </template>

  <template id=GPOS-feature-template>
    <h1>Feature <code class=tag data-field=feature.tag></code></h1>

    <!-- XXX params -->

    <div class=subtables></div>

    <glyph-viewer></glyph-viewer>
  </template>

  <template id=GSUB-lookup-template>
    <h1><span class=nested>Nested</span> Lookup
    #<span data-field=index></span>
    (<code data-field=lookupType></code>)</h1>

    <dl>
      <div>
        <dt><code>lookupType</code>
        <dd>
          <enum-value data-field=lookupType
              label-1="1 (single)"
              label-2="2 (multiple)"
              label-3="3 (alternate)"
              label-4="4 (ligature)"
              label-5="5 (context)"
              label-6="6 (chained context)"
              label-7="7 (extension)"
              label-8="8 (reverse chaining context single)"
          ></enum-value>
      </div>
      <div>
        <dt><code>lookupFlag</code>
        <dd>
          <label><input type=checkbox data-checked-field=lookupFlag-0 disabled data-filled=checked> 0 (RIGHT_TO_LEFT)</label>
          <label><input type=checkbox data-checked-field=lookupFlag-1 disabled data-filled=checked> 1 (IGNORE_BASE_GLYPHS)</label>
          <label><input type=checkbox data-checked-field=lookupFlag-2 disabled data-filled=checked> 2 (IGNORE_LIGATURES)</label>
          <label><input type=checkbox data-checked-field=lookupFlag-3 disabled data-filled=checked> 3 (IGNORE_MARKS)</label>
          <label><input type=checkbox data-checked-field=lookupFlag-4 disabled data-filled=checked> 4 (USE_MARK_FILTERING_SET)</label>
          <label><input type=checkbox data-checked-field=lookupFlag-5 disabled data-filled=checked> 5</label>
          <label><input type=checkbox data-checked-field=lookupFlag-6 disabled data-filled=checked> 6</label>
          <label><input type=checkbox data-checked-field=lookupFlag-7 disabled data-filled=checked> 7</label>
          Mark attachment type:
          <data data-field=lookupFlag-MARK_ATTACHMENT_TYPE></data>
      </div>
      <div>
        <dt><code>markFilteringSet</code>
        <dd><code data-field=markFilteringSet data-empty=?></code><!-- XXX link to GDEF mark glyph set -->
      </div>
    </dl>

    <glyph-viewer></glyph-viewer>
                                                          
    <div class=subtables></div>
  </template>

  <template id=GPOS-lookup-template>
    <h1><span class=nested>Nested</span> Lookup
    #<span data-field=index></span>
    (<code data-field=lookupType></code>)</h1>

    <dl>
      <div>
        <dt><code>lookupType</code>
        <dd>
          <enum-value data-field=lookupType
              label-1="1 (single adjustment)"
              label-2="2 (pair adjustment)"
              label-3="3 (cusive attachment)"
              label-4="4 (MarkToBase attachment)"
              label-5="5 (MarkToLigature attachment)"
              label-6="6 (MarkToMark attachment)"
              label-7="7 (context positioning)"
              label-8="8 (chained context positioning)"
              label-9="9 (extension positioning)"
          ></enum-value>
      </div>
      <div>
        <dt><code>lookupFlag</code>
        <dd>
          <label><input type=checkbox data-checked-field=lookupFlag-0 disabled data-filled=checked> 0 (RIGHT_TO_LEFT)</label>
          <label><input type=checkbox data-checked-field=lookupFlag-1 disabled data-filled=checked> 1 (IGNORE_BASE_GLYPHS)</label>
          <label><input type=checkbox data-checked-field=lookupFlag-2 disabled data-filled=checked> 2 (IGNORE_LIGATURES)</label>
          <label><input type=checkbox data-checked-field=lookupFlag-3 disabled data-filled=checked> 3 (IGNORE_MARKS)</label>
          <label><input type=checkbox data-checked-field=lookupFlag-4 disabled data-filled=checked> 4 (USE_MARK_FILTERING_SET)</label>
          <label><input type=checkbox data-checked-field=lookupFlag-5 disabled data-filled=checked> 5</label>
          <label><input type=checkbox data-checked-field=lookupFlag-6 disabled data-filled=checked> 6</label>
          <label><input type=checkbox data-checked-field=lookupFlag-7 disabled data-filled=checked> 7</label>
          Mark attachment type:
          <data data-field=lookupFlag-MARK_ATTACHMENT_TYPE></data>
      </div>
      <div>
        <dt><code>markFilteringSet</code>
        <dd><code data-field=markFilteringSet data-empty=?></code><!-- XXX link to GDEF mark glyph set -->
      </div>
    </dl>

    <glyph-viewer></glyph-viewer>

    <div class=subtables></div>
  </template>

  <template id=GSUB-lookup-subtable-template>
    <dl>
      <div>
        <dt><code>substFormat</code>
        <dd><enum-value data-field=substFormat></enum-value>
      </div>
      <div>
        <dt><code>deltaGlyphID</code>
        <dd><data data-field=deltaGlyphID data-empty=?></data>
      </div>
      <div>
        <dt><code>extensionLookupType</code>
        <dd><enum-value data-field=lookupType
              label-1="1 (single)"
              label-2="2 (multiple)"
              label-3="3 (alternate)"
              label-4="4 (ligature)"
              label-5="5 (context)"
              label-6="6 (chained context)"
              label-8="8 (reverse chaining context single)"
        ></enum-value>
      </div>
      <div>
        <dt><code>extension.substFormat</code>
        <dd><enum-value data-field=extension.substFormat></enum-value>
      </div>
    </dl>

    <list-viewer listtitle="Glyphs to glyphs mappings" limit=10></list-viewer>

    <div class=classes>
      <p>Backtrack class:</p>
      <glyph-class data-field=backtrackClassDef></glyph-class>
      <p>Input class:</p>
      <glyph-class data-field=inputClassDef></glyph-class>
      <p>Lookahead class:</p>
      <glyph-class data-field=lookaheadClassDef></glyph-class>
    </div>
  </template>

  <template id=GPOS-lookup-subtable-template>
    <dl>
      <div>
        <dt><code>posFormat</code>
        <dd><enum-value data-field=posFormat></enum-value>
      </div>
      <div>
        <dt><code>extensionLookupType</code>
        <dd><enum-value data-field=extensionLookupType
              label-1="1 (single adjustment)"
              label-2="2 (pair adjustment)"
              label-3="3 (cusive attachment)"
              label-4="4 (MarkToBase attachment)"
              label-5="5 (MarkToLigature attachment)"
              label-6="6 (MarkToMark attachment)"
              label-7="7 (context positioning)"
              label-8="8 (chained context positioning)"
        ></enum-value>
      </div>
      <div>
        <dt><code>extension.posFormat</code>
        <dd><enum-value data-field=extension.posFormat></enum-value>
      </div>
    </dl>

    <div class=classes></div>

    <list-viewer listtitle="Glyphs to values mappings" limit=10></list-viewer>
  </template>

  <template id=cmap-table-template>
    <dl>
      <div>
        <dt>Version
        <dd><data data-field=version></data>
      </div>
    </dl>
  </template>

  <template id=cmap-submenu-item-template>
    <a data-href-template="#{list.idPrefix}-cmap-{item.index}" class=cmap-ref>
      (<code data-field=item.platformID></code>,
       <code data-field=item.encodingID></code>,
       <code data-field=item.format></code>)
    </a>
  </template>
  
  <template id=cmap-subtable-template>
    <h1>cmap subtable
    (<code data-field=platformID></code>,
     <code data-field=encodingID></code>,
     <code data-field=format></code>)</h1>
    <dl>
      <div>
        <dt><code>platformID</code>
        <dd>
          <enum-value data-field=platformID
             label-0="0 (Unicode)"
             label-1="1 (Macintosh)"
             label-2="2 (ISO)"
             label-3="3 (Windows)"
             label-4="4 (Custom)"
          ></enum-value>
      </div>
      <div>
        <dt><code>encodingID</code>
        <dd>
          <code data-field=encodingID></code>
          (<enum-value data-field=peID
               label-0-0="Unicode 1.0"
               label-0-1="Unicode 1.1"
               label-0-2="ISO/IEC 10646"
               label-0-3="Unicode 2.0+ BMP"
               label-0-4="Unicode 2.0+ full repertoire"
               label-0-5="Unicode Variation Sequences"
               label-0-6="Unicode full repertoire"
               label-1-0="0 (MacRoman)"
               label-1-1="1 (MacJapanese)"
               label-1-2="2 (MacChineseTrad)"
               label-2-0="7-bit ASCII"
               label-2-1="ISO 10646"
               label-2-2="ISO 8859-1"
               label-3-0="Symbol"
               label-3-1="Unicode BMP"
               label-3-2="Shift JIS"
               label-3-3="PRC"
               label-3-4="Big5"
               label-3-5="Wansung"
               label-3-6="Johab"
               label-3-10="Unicode full repertoire"
           ></enum-value>)
      </div>
      <div>
        <dt><code>format</code>
        <dd><enum-value data-field=format
            label-0="0 (byte encoding table)"
            label-2="2 (high-byte mapping through table)"
            label-4="4 (segment mapping to delta values)"
            label-6="6 (trimmed table mapping)"
            label-8="8 (mixed 16-bit and 32-bit coverage)"
            label-10="10 (trimmed array)"
            label-12="12 (segmented coverage)"
            label-13="13 (many-to-one range mappings)"
            label-14="14 (Unicode variation sequences)"
        ></enum-value>
      </div>
      <div>
        <dt>language ID = <code>language</code> - 1
        <dd><enum-value data-field=languageID
            label-null="not language-specific"
        ></enum-value>
      </div>
      <div>
        <dt>Number of glyphs
        <dd><data data-field=glyphNumber></data>
      </div>
    </dl>

    <glyph-viewer></glyph-viewer>

    <list-viewer listtitle="Character to glyph mappings"></list-viewer>
  </template>

  <template id=hhea-table-template>
    <dl>
      <div>
        <dt>Version
        <dd><data data-field=version></data>
      </div>
      <div>
        <dt><code>ascender</code>
        <dd><data data-field=ascender></data>
      </div>
      <div>
        <dt><code>descender</code>
        <dd><data data-field=descender></data>
      </div>
      <div>
        <dt><code>lineGap</code>
        <dd><data data-field=lineGap></data>
      </div>
      <div>
        <dt><code>advanceWidthMax</code>
        <dd><data data-field=advanceWidthMax></data>
      </div>
      <div>
        <dt><code>minLeftSideBearing</code>
        <dd><data data-field=minLeftSideBearing></data>
      </div>
      <div>
        <dt><code>minRightSideBearing</code>
        <dd><data data-field=minRightSideBearing></data>
      </div>
      <div>
        <dt><code>xMaxExtent</code>
        <dd><data data-field=xMaxExtent></data>
      </div>
      <div>
        <dt><code>caretSlopeRise</code>
        <dd><data data-field=caretSlopeRise></data>
      </div>
      <div>
        <dt><code>caretSlopeRun</code>
        <dd><data data-field=caretSlopeRun></data>
      </div>
      <div>
        <dt><code>caretOffset</code>
        <dd><data data-field=caretOffset></data>
      </div>
      <div>
        <dt><code>metricDataFormat</code>
        <dd>
          <enum-value data-field=metricDataFormat
          ></enum-value>
      </div>
      <div>
        <dt><code>numberOfHMetrics</code>
        <dd><data data-field=numberOfHMetrics></data>
      </div>
    </dl>
  </template>

  <template id=vhea-table-template>
    <dl>
      <div>
        <dt>Version
        <dd><data data-field=version></data>
      </div>
      <div>
        <dt><code>vertTypoAscender</code>
        <dd><data data-field=vertTypoAscender></data>
      </div>
      <div>
        <dt><code>vertTypoDescender</code>
        <dd><data data-field=vertTypoDescender></data>
      </div>
      <div>
        <dt><code>vertTypoLineGap</code>
        <dd><data data-field=vertTypoLineGap></data>
      </div>
      <div>
        <dt><code>advanceHeightMax</code>
        <dd><data data-field=advanceHeightMax></data>
      </div>
      <div>
        <dt><code>minTopSideBearing</code>
        <dd><data data-field=minTopSideBearing></data>
      </div>
      <div>
        <dt><code>minBottomSideBearing</code>
        <dd><data data-field=minBottomSideBearing></data>
      </div>
      <div>
        <dt><code>yMaxExtent</code>
        <dd><data data-field=yMaxExtent></data>
      </div>
      <div>
        <dt><code>caretSlopeRise</code>
        <dd><data data-field=caretSlopeRise></data>
      </div>
      <div>
        <dt><code>caretSlopeRun</code>
        <dd><data data-field=caretSlopeRun></data>
      </div>
      <div>
        <dt><code>caretOffset</code>
        <dd><data data-field=caretOffset></data>
      </div>
      <div>
        <dt><code>metricDataFormat</code>
        <dd>
          <enum-value data-field=metricDataFormat
          ></enum-value>
      </div>
      <div>
        <dt><code>numberOfLongVerMetrics</code>
        <dd><data data-field=numberOfLongVerMetrics></data>
      </div>
    </dl>
  </template>

  <template id=GDEF-table-template>
    <dl>
      <div>
        <dt>Version
        <dd><data data-field=version></data>
      </div>
    </dl>

    <section class=subtable>
      <h1>Glyph class definition</h1>

      <glyph-class data-field=classDef></glyph-class>
    </section>
    
    <!-- XXX attach list -->

    <p>Ligature caret list:
    <span class=data-field=ligCaretList.ligGlyphs.length></span>

    <section class=subtable>
      <h1>Mark attachment class definition</h1>

      <glyph-class data-field=markAttachClassDef></glyph-class>
    </section>

    <p>Mark glyph set definition:
    <dl>
      <div>
        <dt><code>format</code>
        <dd><enum-value data-field=XXX.format></enum-value>
      </div>
      <!-- XXX ranges -->
    </dl>

    <!-- XXX item variation store -->
  </template>

  <template id=glyph-viewer-template>
    <form is=glyph-viewer-input>
      <p>
        <label>Text: <input type=search name=inputText></label>
        <label>Char code(s): <input type=search pattern='\s*([0-9]+|(0x|U\+)[0-9A-Fa-f]+|"[^"]+")(\s+([0-9]+|(0x|U\+)[0-9A-Fa-f]+|"[^"]+"))*\s*' name=inputHex></label>
        <label data-glyph-viewer-type=input-glyph>Glyph ID(s): <input type=search name=inputGlyphID pattern="\s*[0-9]+(\s+[0-9]+)*\s*"></label>
        <label><input type=checkbox name=inputIsUnicode> Unicode</label>
        <label><input type=checkbox name=inputIsDefault> Default</label>
        <label><input type=checkbox name=inputIsBreak> Break</label>
        <span class=feature-list>Features: </span>
      </p>
    </form>
    <glyph-viewer-result-items></glyph-viewer-result-items>
  </template>
  
  <template id=glyph-viewer-step-default-template>
    Default
    <enum-value data-field=isFallback 
      label-true=Fallback label-false label-undefined
    ></enum-value>
  </template>

  <template id=glyph-viewer-step-break-template>
    Break
  </template>

  <template id=glyph-viewer-step-glyph-name-template>
    Glyph name: <code data-field=glyphName></code>
  </template>

  <template id=glyph-viewer-step-cmaps-template>
    <item-list data-field=cmaps template=item-list-cmap-template></item-list>
  </template>
  <template id=glyph-viewer-step-cmap-no-match-template>
    No match in <code>cmap</code>s
  </template>

  <template id=glyph-viewer-step-lookup-template>
    Lookup #<span data-field=lookup.index></span>
    for feature <code class=tag data-field=feature.tag></code>
  </template>

  <template id=glyph-viewer-step-OS/2-default-template>
    <code>OS/2</code>.<code>usDefaultChar</code>
  </template>

  <template id=glyph-viewer-step-OS/2-break-template>
    <code>OS/2</code>.<code>usBreakChar</code>
  </template>

  <template id=glyph-viewer-step-char-template>
    Character:
    <char-code data-field=charCode data-isunicode-field=isUnicodeAttr data-filled=isunicode></char-code>
    <enum-value data-field=isVSFallback 
      label-true=Fallback label-false label-undefined
    ></enum-value>
    <enum-value data-field=isDefault
      label-true=Default label-false label-undefined
    ></enum-value>
  </template>

  <template id=glyph-viewer-step-vs-template>
    VS:
    <item-list data-field=charCodes template=item-list-char-template></item-list>
    <data data-field=string></data>
  </template>

  <template id=glyph-viewer-step-glyph-template>
    <p><a data-href-template="#{idPrefix}-glyph-{glyphID}">Glyph
    <code data-field=glyphID></code></a>
    <enum-value data-field=isVSFallback 
      label-true=Fallback label-false label-undefined
    ></enum-value>
    <enum-value data-field=isDefault
      label-true=Default label-false label-undefined
    ></enum-value>
    <enum-value data-field=isFallback 
      label-true=Fallback label-false label-undefined
    ></enum-value>
    <enum-value data-field=notFound
      label-true="Glyph data not found" label-false label-undefined
    ></enum-value>
    <p><glyph-image size=64 data-field=glyphID></glyph-image>
  </template>
  
  <template id=glyph-viewer-step-glyph-values-template>
    <a href=javascript: class=glyph-button>Glyph + positions</a>
    advance: (<data data-field=values.0.value.xAdvance data-empty=?></data>,
              <data data-field=values.0.value.yAdvance data-empty=?></data>)
    placement: (<data data-field=values.0.value.xPlacement data-empty=?></data>,
              <data data-field=values.0.value.yPlacement data-empty=?></data>)
    plaDeviceOffset: (<data data-field=values.0.value.xPlaDeviceOffset data-empty=?></data>,
              <data data-field=values.0.value.yPlaDeviceOffset data-empty=?></data>)
    advDeviceOffset: (<data data-field=values.0.value.xAdvDeviceOffset data-empty=?></data>,
              <data data-field=values.0.value.yAdvDeviceOffset data-empty=?></data>)
    anchor: (<data data-field=values.0.anchor.xCoordinate data-empty=?></data>,
             <data data-field=values.0.anchor.yCoordinate data-empty=?></data>)
    <code>anchorPoint</code> <data data-field=values.0.anchor.anchorPoint data-empty=?></data>
    anchor device offset: (<data data-field=values.0.anchor.xDeviceOffset data-empty=?></data>,
             <data data-field=values.0.anchor.yDeviceOffset data-empty=?></data>)
    entry anchor: (<data data-field=values.0.entryAnchor.xCoordinate data-empty=?></data>,
             <data data-field=values.0.entryAnchor.yCoordinate data-empty=?></data>)
    <code>anchorPoint</code> <data data-field=values.0.entryAnchor.anchorPoint data-empty=?></data>
    anchor device offset: (<data data-field=values.0.entryAnchor.xDeviceOffset data-empty=?></data>,
                           <data data-field=values.0.entryAnchor.yDeviceOffset data-empty=?></data>)
    exit anchor: (<data data-field=values.0.exitAnchor.xCoordinate data-empty=?></data>,
             <data data-field=values.0.exitAnchor.yCoordinate data-empty=?></data>)
    <code>anchorPoint</code> <data data-field=values.0.exitAnchor.anchorPoint data-empty=?></data>
    anchor device offset: (<data data-field=values.0.exitAnchor.xDeviceOffset data-empty=?></data>,
             <data data-field=values.0.exitAnchor.yDeviceOffset data-empty=?></data>)
    direction: <enum-value data-field=values.0.rtl
                   label-0=ltr label-1=rtl
               ></enum-value>
  </template>

  <template id=glyph-data>
    <glyph-data-main>
      <p><glyph-image details size=320 data-field=glyphIDAndPosValues></glyph-image>
      <p>
        <glyph-image details size=128 data-field=glyphIDAndPosValues></glyph-image>
        <glyph-image details size=128 variant=subscript data-field=glyphIDAndPosValues></glyph-image>
        <glyph-image details size=128 variant=superscript data-field=glyphIDAndPosValues></glyph-image>
      <p><code>head</code>.<code>lowestRecPPEM</code> =
      <data data-field=font.tables.head.lowestRecPPEM></data>:
         <glyph-image details size=lowestRec data-field=glyphIDAndPosValues></glyph-image>;
    8:   <glyph-image details size=8 data-field=glyphIDAndPosValues></glyph-image>;
    16:  <glyph-image details size=16 data-field=glyphIDAndPosValues></glyph-image>;
    32:  <glyph-image details size=32 data-field=glyphIDAndPosValues></glyph-image>
       </p>
    </glyph-data-main>
    <glyph-data-props>
      <dl>
      <div>
        <dt>Axes
        <dd>
          <p><label class="line axis">
            <input type=checkbox name=shown value=axis checked> x- and y-axes
          </label>
          <p><label class="line vaxis">
            <input type=checkbox name=shown value=vaxis checked>
            vertical x- and y-axes
          </label>
          <p>(<code class=tag data-field=posValues.xPlacementFeature.tag></code>,
           <code class=tag data-field=posValues.yPlacementFeature.tag></code>):
          (<data data-field=posValues.xPlacement data-empty=?></data>,
           <data data-field=posValues.yPlacement data-empty=?></data>)
      </div>
      <div>
        <dt>Boxes
        <dd>
          <p><label class="line bounding">
            <input type=checkbox name=shown value=bounding checked>
            <code>head</code> glyph's bounding box
          </label>:
          <data data-field=font.tables.head.yMin></data>,
          <data data-field=font.tables.head.xMax></data>,
          <data data-field=font.tables.head.xMin></data>,
          <data data-field=font.tables.head.yMax></data>
          <p><label class="line ideoEmbox">
            <input type=checkbox name=shown value=ideoEmbox>
            <code>BASE</code> ideographic em-box
          </label>:
          <data data-field=font.ideoEmboxTop data-empty=?></data>,
          <data data-field=font.ideoEmboxRight data-empty=?></data>,
          <data data-field=font.ideoEmboxBottom data-empty=?></data>,
          <data data-field=font.ideoEmboxLeft data-empty=?></data>;
          (<data data-field=font.ideoEmboxCenterVertical data-empty=?></data>,
          <data data-field=font.ideoEmboxCenterHorizontal data-empty=?></data>)
          <p><label class="line icf">
            <input type=checkbox name=shown value=icf>
            <code>BASE</code> ideographic character face
          </label>:
          <data data-field=font.tables.base.icfTop data-empty=?></data>,
          <data data-field=font.tables.base.icfRight data-empty=?></data>,
          <data data-field=font.tables.base.icfBottom data-empty=?></data>,
          <data data-field=font.tables.base.icfLeft data-empty=?></data>;
          (<data data-field=font.tables.base.icfCenterVertical data-empty=?></data>,
          <data data-field=font.tables.base.icfCenterHorizontal data-empty=?></data>)
      </div>
      <div>
        <dt>Baselines
        <dd>
          <p><label class="line baseline hang">
            <input type=checkbox name=shown value=hang>
            hanging baseline
          </label>:
          <code>BASE</code>.<code>HorizAxis</code>.<code>hang</code>:
          <data data-field=font.tables.base.horizAxis.DFLT.hang data-empty=?></data>,
          <code>BASE</code>.<code>VertAxis</code>.<code>hang</code>:
          <data data-field=font.tables.base.vertAxis.DFLT.hang data-empty=?></data>
          <p><label class="line baseline icfb">
            <input type=checkbox name=shown value=icfb>
            ideographic character face bottom/left edge
          </label>:
          <code>BASE</code>.<code>HorizAxis</code>.<code>icfb</code>:
          <data data-field=font.tables.base.horizAxis.DFLT.icfb data-empty=?></data>,
          <code>BASE</code>.<code>VertAxis</code>.<code>icfb</code>:
          <data data-field=font.tables.base.vertAxis.DFLT.icfb data-empty=?></data>
          <p><label class="line baseline icft">
            <input type=checkbox name=shown value=icft>
            ideographic character face top/right edge
          </label>:
          <code>BASE</code>.<code>HorizAxis</code>.<code>icft</code>:
          <data data-field=font.tables.base.horizAxis.DFLT.icft data-empty=?></data>,
          <code>BASE</code>.<code>VertAxis</code>.<code>icft</code>:
          <data data-field=font.tables.base.vertAxis.DFLT.icft data-empty=?></data>
          <p><label class="line baseline ideo">
            <input type=checkbox name=shown value=ideo>
            ideographic em-box bottom/left edge
          </label>:
          <code>BASE</code>.<code>HorizAxis</code>.<code>ideo</code>:
          <data data-field=font.tables.base.horizAxis.DFLT.ideo data-empty=?></data>,
          <code>BASE</code>.<code>VertAxis</code>.<code>ideo</code>:
          <data data-field=font.tables.base.vertAxis.DFLT.ideo data-empty=?></data>
          <p><label class="line baseline idtp">
            <input type=checkbox name=shown value=idtp>
            ideographic em-box top/right edge
          </label>:
          <code>BASE</code>.<code>HorizAxis</code>.<code>idtp</code>:
          <data data-field=font.tables.base.horizAxis.DFLT.idtp data-empty=?></data>,
          <code>BASE</code>.<code>VertAxis</code>.<code>idtp</code>:
          <data data-field=font.tables.base.vertAxis.DFLT.idtp data-empty=?></data>
          <p><label class="line baseline math">
            <input type=checkbox name=shown value=math>
            math
          </label>:
          <code>BASE</code>.<code>HorizAxis</code>.<code>math</code>:
          <data data-field=font.tables.base.horizAxis.DFLT.math data-empty=?></data>,
          <code>BASE</code>.<code>VertAxis</code>.<code>math</code>:
          <data data-field=font.tables.base.vertAxis.DFLT.math data-empty=?></data>
          <p><label class="line baseline romn">
            <input type=checkbox name=shown value=romn>
            romn
          </label>:
          <code>BASE</code>.<code>HorizAxis</code>.<code>romn</code>:
          <data data-field=font.tables.base.horizAxis.DFLT.romn data-empty=?></data>,
          <code>BASE</code>.<code>VertAxis</code>.<code>romn</code>:
          <data data-field=font.tables.base.vertAxis.DFLT.romn data-empty=?></data>
          <p><code>head</code>.<code>flags</code>:
          <label><input type=checkbox data-checked-field=font.tables.head.flags-0 disabled data-filled=checked> baseline at y = 0</label>
      </div>
      <div>
        <dt>Heights
        <dd>
          <p><label class="line typo">
            <input type=checkbox name=shown value=typo> typographic metrics
          </label>:
          <code>OS/2</code>.<code>sTypoAscender</code>:
          <data data-field=font.tables.os2.sTypoAscender></data>,
          <code>OS/2</code>.<code>sTypoDescender</code>:
          <data data-field=font.tables.os2.sTypoDescender></data>,
          <code>OS/2</code>.<code>sTypoLineGap</code>:
          <data data-field=font.tables.os2.sTypoLineGap></data>
          <p><label class="line win">
            <input type=checkbox name=shown value=win> Windows metrics
          </label>:
          <code>OS/2</code>.<code>usWinAscent</code>:
          <data data-field=font.tables.os2.usWinAscent></data>,
          <code>OS/2</code>.<code>usWinDescent</code>:
          <data data-field=font.tables.os2.usWinDescent></data>
          <p><label class="line height">
            <input type=checkbox name=shown value=height> heights
          </label>:
          <code>OS/2</code>.<code>sxHeight</code>:
          <data data-field=font.tables.os2.sxHeight data-empty=?></data>,
          <code>OS/2</code>.<code>sCapHeight</code>:
          <data data-field=font.tables.os2.sCapHeight data-empty=?></data>
          <p><label class="line hheaheight">
            <input type=checkbox name=shown value=hheaheight> <code>hhea</code>
          </label>:
          <code>hhea</code>.<code>ascender</code>:
          <data data-field=font.tables.hhea.ascender></data>,
          <code>hhea</code>.<code>descender</code>:
          <data data-field=font.tables.hhea.descender></data>,
          <code>hhea</code>.<code>lineGap</code>:
          <data data-field=font.tables.hhea.lineGap></data>
          <p><code>OS/2</code>.<code>fsSelection</code>:
          <label><input type=checkbox data-checked-field=font.tables.os2.fsSelection-7 disabled data-filled=checked> USE_TYPO_METRICS</label>
          <hr>
          <p><label class="line vheaheight">
            <input type=checkbox name=shown value=vheaheight> <code>vhea</code>
          </label>:
          <code>vhea</code>.<code>advanceHeightMax</code>:
          <data data-field=font.tables.vhea.advanceHeightMax data-empty=?></data>,
          <code>vhea</code>.<code>minTopSideBearing</code>:
          <data data-field=font.tables.vhea.minTopSideBearing data-empty=?></data>,
          <code>vhea</code>.<code>minBottomSideBearing</code>:
          <data data-field=font.tables.vhea.minBottomSideBearing data-empty=?></data>,
          <code>vhea</code>.<code>yMaxExtent</code>:
          <data data-field=font.tables.vhea.yMaxExtent data-empty=?></data>
      </div>
      <div>
        <dt>Widths
        <dd>
          <p><label class="line average">
            <input type=checkbox name=shown value=average>
            <code>OS/2</code>.<code>xAvgCharWidth</code>
          </label>:
          <data data-field=font.tables.os2.xAvgCharWidth></data>
          <p><label class="line hheawidth">
            <input type=checkbox name=shown value=hheawidth> <code>hhea</code>
          </label>:
          <code>hhea</code>.<code>advanceWidthMax</code>:
          <data data-field=font.tables.hhea.advanceWidthMax></data>,
          <code>hhea</code>.<code>minLeftSideBearing</code>:
          <data data-field=font.tables.hhea.minLeftSideBearing></data>,
          <code>hhea</code>.<code>minRightSideBearing</code>:
          <data data-field=font.tables.hhea.minRightSideBearing></data>,
          <code>hhea</code>.<code>xMaxExtent</code>:
          <data data-field=font.tables.hhea.xMaxExtent></data>
          <p><code>head</code>.<code>flags</code>:
          <label><input type=checkbox data-checked-field=font.tables.head.flags-1 disabled data-filled=checked> left sidebearing point at x = 0</label>
          <label><input type=checkbox data-checked-field=font.tables.head.flags-4 disabled data-filled=checked> may alter advance width</label>
          <hr>
          <p><label class="line vheawidth">
            <input type=checkbox name=shown value=vheawidth> vertical
            typographic metrics
          </label>:
          <code>vhea</code>.<code>vertTypoAscender</code>:
          <data data-field=font.tables.vhea.vertTypoAscender data-empty=?></data>,
          <code>vhea</code>.<code>vertTypoDescender</code>:
          <data data-field=font.tables.vhea.vertTypoDescender data-empty=?></data>,
          <code>vhea</code>.<code>vertTypoLineGap</code>:
          <data data-field=font.tables.vhea.vertTypoLineGap data-empty=?></data>
      </div>
      <div>
        <dt>Variants
        <dd>
          <p><code>OS/2</code> subscript:
          size (<data data-field=font.tables.os2.ySubscriptXSize></data>,
                <data data-field=font.tables.os2.ySubscriptYSize></data>),
          offset (<data data-field=font.tables.os2.ySubscriptXOffset></data>,
                  <data data-field=font.tables.os2.ySubscriptYOffset></data>)
          <p><code>OS/2</code> superscript:
          size (<data data-field=font.tables.os2.ySuperscriptXSize></data>,
                <data data-field=font.tables.os2.ySuperscriptYSize></data>),
          offset (<data data-field=font.tables.os2.ySuperscriptXOffset></data>,
                  <data data-field=font.tables.os2.ySuperscriptYOffset></data>)
          <p><label class="line italic">
            <input type=checkbox name=shown value=italic>
            <code>post</code>.<code>itaicAngle</code>
          </label>:
          <data data-field=font.tables.post.italicAngle></data>;
          <code>hhea</code>.<code>caret</code>:
          <code>SlopeRise</code>: <data data-field=font.tables.hhea.caretSlopeRise></data>,
          <code>SlopeRun</code>: <data data-field=font.tables.hhea.caretSlopeRun></data>,
          <code>Offset</code>: <data data-field=font.tables.hhea.caretOffset></data>;
          <code>vhea</code>.<code>caret</code>:
          <code>SlopeRise</code>: <data data-field=font.tables.vhea.caretSlopeRise></data>,
          <code>SlopeRun</code>: <data data-field=font.tables.vhea.caretSlopeRun></data>,
          <code>Offset</code>: <data data-field=font.tables.vhea.caretOffset></data>
      </div>
      <div>
        <dt>Decorations
        <dd>
          <p><label class="line strikeout">
            <input type=checkbox name=shown value=strikeout>
            <code>OS/2</code> strikeout
          </label>:
          <code>size</code>: <data data-field=font.tables.os2.yStrikeoutSize></data>,
          <code>position</code>: <data data-field=font.tables.os2.yStrikeoutPosition></data>
          <p><label class="line underline">
            <input type=checkbox name=shown value=underline>
            <code>post</code> underline
          </label>:
          <code>thickness</code>: <data data-field=font.tables.post.underlineThickness></data>
          <code>position</code>: <data data-field=font.tables.post.underlinePosition></data>
      </div>
      <div>
        <dt>Glyph
        <dd>
          <p><label class="line advance">
            <input type=checkbox name=shown value=advance checked>
            advance
          </label>:
          <code>hmtx</code>.advanceWidth:
          <data data-field=glyph.advanceWidth></data>,
          <code>vmtx</code>.advanceHeight:
          <data data-field=glyph.advanceHeight data-empty=?></data>

          (<code class=tag data-field=posValues.xAdvanceFeature.tag></code>,
           <code class=tag data-field=posValues.yAdvanceFeature.tag></code>):
          (<data data-field=posValues.xAdvance data-empty=?></data>,
           <data data-field=posValues.yAdvance data-empty=?></data>)

          <p><label class="line sideBearing">
            <input type=checkbox name=shown value=sideBearing>
            side bearing
          </label>:
          <code>hmtx</code>.leftSideBearing:
          <data data-field=glyph.leftSideBearing></data>,
          <code>hmtx</code>.rightSideBearing:
          <data data-field=glyph.metrics.rightSideBearing></data>,
          <code>vmtx</code>.topSideBearing:
          <data data-field=glyph.topSideBearing></data>
          <p><label class="line glyph">
            <input type=checkbox name=shown value=glyph>
            bounding box
          </label>:
          <code>glyf</code> <var>x</var>: [<data data-field=glyph._xMin></data>,
                         <data data-field=glyph._xMax></data>],
          <code>glyf</code> <var>y</var>: [<data data-field=glyph._yMin></data>,
                         <data data-field=glyph._yMax></data>]
      </div>
      <div>
        <dt>Anchors
        <dd>
          <label class="point mark anchor">
            <input type=checkbox name=shown value=mark checked>
            Entry (<code data-field=posValues.anchorFeature.tag></code>):
            (<data data-field=posValues.anchor.xCoordinate data-empty=?></data>,
             <data data-field=posValues.anchor.yCoordinate data-empty=?></data>)
          </label>
          <label class="point entry anchor">
            <input type=checkbox name=shown value=entry checked>
            Entry (<code data-field=posValues.entryAnchorFeature.tag></code>):
            (<data data-field=posValues.entryAnchor.xCoordinate data-empty=?></data>,
             <data data-field=posValues.entryAnchor.yCoordinate data-empty=?></data>)
          </label>
          <label class="point exit anchor">
            <input type=checkbox name=shown value=exit checked>
            Exit (<code data-field=posValues.exitAnchorFeature.tag></code>):
            (<data data-field=posValues.exitAnchor.xCoordinate data-empty=?></data>,
             <data data-field=posValues.exitAnchor.yCoordinate data-empty=?></data>)
           </label>
           Direction: <enum-value data-field=posValues.rtl
                          label-0=ltr label-1=rtl
                      ></enum-value>
      </div>
      <div>
        <dt><code>head</code>.<code>unitsPerEm</code>
        <dd><data data-field=font.tables.head.unitsPerEm></data>
      </div>
      <div>
        <dt><code>OS/2</code>.<code>usMaxContext</code>
        <dd><data data-field=font.tables.os2.usMaxContext data-empty=?></data>
      </div>
    </dl>

    <dl>
      <div>
        <dt>Glyph ID
        <dd><code data-field=glyphID></code>
      </div>
      <div>
        <dt>Glyph name
        <dd><code data-field=glyphName data-empty=?></code>
      </div>
      <div>
        <dt>Glyph class
        <dd>
          <enum-value data-field=glyphClass
              label-0="0 (unknown)"
              label-1="1 (base)"
              label-2="2 (ligature)"
              label-3="3 (mark)"
              label-4="4 (component)"
          ></enum-value>
      </div>
      <div>
        <dt>Mark attachment glyph class
        <dd>
          <enum-value data-field=markAttachGlyphClass
              label-0="0 (unknown)"
          ></enum-value>
        </div>
      </dl>
    </glyph-data-props>
  </template>

  <template id=glyph-class-template>
    <dl>
      <div>
        <dt><code>classFormat</code>
        <dd><enum-value data-field=format></enum-value>
      </div>
    </dl>

    <div class=items></div>
  </template>

  <template id=list-glyphs-template>
    <p><a data-href-template="#{idPrefix}-glyph-{glyphID}">Glyph
    <code data-field=glyphID></code></a>
    <p><glyph-image size=64 data-field=glyphID></glyph-image>
  </template>

  <template id=list-glyphNames-template>
    <p>Glyph name: <code data-field=glyphName></code>
    <p><a data-href-template="#{idPrefix}-glyph-{glyphID}">Glyph
    <code data-field=glyphID></code></a>
    <p><glyph-image size=64 data-field=glyphID></glyph-image>
  </template>

  <template id=list-cmap-template>
    <p>Character:
    <item-list data-field=charCodes template=item-list-char-template></list-item>
    <p data-hidden-field=toCharCodeHidden data-filled=hidden>Same as: character
    <char-code data-field=toCharCode isunicode data-viewerselector-template="#{idPrefix}-glyphs glyph-viewer" data-filled=viewerselector></char-code>
    <p data-hidden-field=glyphHidden data-filled=hidden>
      <a data-href-template="#{idPrefix}-glyph-{glyphID}">Glyph
      <code data-field=glyphID></code></a>
    <p data-hidden-field=glyphHidden data-filled=hidden>
      <glyph-image size=64 data-field=glyphID></glyph-image>
  </template>

  <template id=list-GSUBLookupSubtable-template>
    <div>
      <span>Original</span>
      <item-list data-field=srcGlyphs template=item-list-glyph-template></item-list>
    </div>
    <div>
      <span>Replaced</span>
      <item-list data-field=glyphs template=item-list-glyph-template></item-list>
    </div>
  </template>

  <template id=list-GPOSLookupSubtable-template>
    <item-list data-field=glyphs template=item-list-glyph-template></item-list>
    <item-list data-field=values template=item-list-value-template></item-list>
  </template>

  <template id=list-glyphClass-template>
    <p><a data-href-template="#{idPrefix}-glyph-{glyphID}">Glyph
    <code data-field=glyphID></code></a>
    <p><glyph-image size=64 data-field=glyphID></glyph-image>
  </template>

  <template id=item-list-tag-swml-template>[CODE[<data data-field=item.tag></data>]], </template>

  <template id=item-list-char-template>
    <char-code data-field=item.charCode data-isunicode-field=item.isUnicodeAttr data-filled=isunicode></char-code>
  </template>

  <template id=item-list-glyph-template>
    <p><a data-href-template="#{list.idPrefix}-glyph-{item.glyphID}">Glyph
    <code data-field=item.glyphID></code></a>
      <enum-value data-field=item.position
        label-undefined label-0
        label-1=lookahead
        label--1=backtrack
      ></enum-value>
    <p><glyph-image size=64 data-field=item.glyphID></glyph-image>
  </template>

  <template id=item-list-cmap-template>
    <a data-href-template="#{list.idPrefix}-cmap-{item.index}" class=cmap-ref>
      <code>cmap</code>
      (<code data-field=item.platformID></code>,
       <code data-field=item.encodingID></code>,
       <code data-field=item.format></code>)
    </a>
  </template>

  <template id=item-list-value-template>
    <a href=javascript: class=glyph-button data-data-index-field=index data-filled=data-index>Glyph + positions</a>
    advance: (<data data-field=item.value.xAdvance data-empty=?></data>,
              <data data-field=item.value.yAdvance data-empty=?></data>)
    placement: (<data data-field=item.value.xPlacement data-empty=?></data>,
              <data data-field=item.value.yPlacement data-empty=?></data>)
    plaDeviceOffset: (<data data-field=item.value.xPlaDeviceOffset data-empty=?></data>,
              <data data-field=item.value.yPlaDeviceOffset data-empty=?></data>)
    advDeviceOffset: (<data data-field=item.value.xAdvDeviceOffset data-empty=?></data>,
                <data data-field=item.value.yAdvDeviceOffset data-empty=?></data>)
    anchor: (<data data-field=item.anchor.xCoordinate data-empty=?></data>,
               <data data-field=item.anchor.yCoordinate data-empty=?></data>)
    <code>anchorPoint</code> <data data-field=item.anchor.anchorPoint data-empty=?></data>
    anchor device offset: (<data data-field=item.anchor.xDeviceOffset data-empty=?></data>,
               <data data-field=item.anchor.yDeviceOffset data-empty=?></data>)
    entry anchor: (<data data-field=item.entryAnchor.xCoordinate data-empty=?></data>,
               <data data-field=item.entryAnchor.yCoordinate data-empty=?></data>)
    <code>anchorPoint</code> <data data-field=item.entryAnchor.anchorPoint data-empty=?></data>
    anchor device offset: (<data data-field=item.entryAnchor.xDeviceOffset data-empty=?></data>,
               <data data-field=item.entryAnchor.yDeviceOffset data-empty=?></data>)
    exit anchor: (<data data-field=item.exitAnchor.xCoordinate data-empty=?></data>,
               <data data-field=item.exitAnchor.yCoordinate data-empty=?></data>)
    <code>anchorPoint</code> <data data-field=item.exitAnchor.anchorPoint data-empty=?></data>
    anchor device offset: (<data data-field=item.exitAnchor.xDeviceOffset data-empty=?></data>,
               <data data-field=item.exitAnchor.yDeviceOffset data-empty=?></data>)
    rtl: <enum-value data-field=item.rtl></enum-value>
  </template>
    
<!--

Copyright 2022-2023 Wakaba <wakaba@suikawiki.org>.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public
License along with this program.  If not, see
<https://www.gnu.org/licenses/>.

-->
